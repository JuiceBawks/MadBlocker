"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectMongoClient = exports.MongoAutoencryptionUnavailable = void 0;
const fast_failure_connect_1 = require("./fast-failure-connect");
class MongoAutoencryptionUnavailable extends Error {
    constructor() {
        super('Automatic encryption is only available with Atlas and MongoDB Enterprise');
    }
}
exports.MongoAutoencryptionUnavailable = MongoAutoencryptionUnavailable;
async function connectWithFailFast(uri, client, logger) {
    var _a;
    const failedConnections = new Map();
    let failEarlyClosePromise = null;
    logger.emit('devtools-connect:connect-attempt-initialized', {
        uri,
        driver: client.options.metadata.driver,
        devtoolsConnectVersion: require('../package.json').version,
        host: (_a = client.options.srvHost) !== null && _a !== void 0 ? _a : client.options.hosts.join(',')
    });
    const heartbeatFailureListener = ({ failure, connectionId }) => {
        var _a;
        const topologyDescription = (_a = client.topology) === null || _a === void 0 ? void 0 : _a.description;
        const servers = topologyDescription === null || topologyDescription === void 0 ? void 0 : topologyDescription.servers;
        const isFailFast = (0, fast_failure_connect_1.isFastFailureConnectionError)(failure);
        const isKnownServer = !!(servers === null || servers === void 0 ? void 0 : servers.has(connectionId));
        logger.emit('devtools-connect:connect-heartbeat-failure', {
            connectionId,
            failure,
            isFailFast,
            isKnownServer
        });
        if (!isKnownServer) {
            return;
        }
        if (isFailFast && servers) {
            failedConnections.set(connectionId, failure);
            if ([...servers.keys()].every(server => failedConnections.has(server))) {
                logger.emit('devtools-connect:connect-fail-early');
                failEarlyClosePromise = client.close();
            }
        }
    };
    const heartbeatSucceededListener = ({ connectionId }) => {
        logger.emit('devtools-connect:connect-heartbeat-succeeded', { connectionId });
        failedConnections.delete(connectionId);
    };
    client.addListener('serverHeartbeatFailed', heartbeatFailureListener);
    client.addListener('serverHeartbeatSucceeded', heartbeatSucceededListener);
    try {
        await client.connect();
    }
    catch (err) {
        if (failEarlyClosePromise !== null) {
            await failEarlyClosePromise;
            throw failedConnections.values().next().value;
        }
        throw err;
    }
    finally {
        client.removeListener('serverHeartbeatFailed', heartbeatFailureListener);
        client.removeListener('serverHeartbeatSucceeded', heartbeatSucceededListener);
        logger.emit('devtools-connect:connect-attempt-finished');
    }
}
let resolveDnsHelpers;
async function resolveMongodbSrv(uri, logger) {
    const resolutionDetails = [];
    if (uri.startsWith('mongodb+srv://')) {
        try {
            resolveDnsHelpers !== null && resolveDnsHelpers !== void 0 ? resolveDnsHelpers : (resolveDnsHelpers = {
                resolve: require('resolve-mongodb-srv'),
                osDns: require('os-dns-native')
            });
        }
        catch (error) {
            logger.emit('devtools-connect:resolve-srv-error', {
                from: '', error, duringLoad: true, resolutionDetails
            });
        }
        if (resolveDnsHelpers !== undefined) {
            try {
                const { wasNativelyLookedUp, withNodeFallback: { resolveSrv, resolveTxt } } = resolveDnsHelpers.osDns;
                const resolved = await resolveDnsHelpers.resolve(uri, {
                    dns: {
                        resolveSrv(hostname, cb) {
                            resolveSrv(hostname, (...args) => {
                                var _a;
                                resolutionDetails.push({
                                    query: 'SRV', hostname, error: (_a = args[0]) === null || _a === void 0 ? void 0 : _a.message, wasNativelyLookedUp: wasNativelyLookedUp(args[1])
                                });
                                cb(...args);
                            });
                        },
                        resolveTxt(hostname, cb) {
                            resolveTxt(hostname, (...args) => {
                                var _a;
                                resolutionDetails.push({
                                    query: 'TXT', hostname, error: (_a = args[0]) === null || _a === void 0 ? void 0 : _a.message, wasNativelyLookedUp: wasNativelyLookedUp(args[1])
                                });
                                cb(...args);
                            });
                        }
                    }
                });
                logger.emit('devtools-connect:resolve-srv-succeeded', { from: uri, to: resolved, resolutionDetails });
                return resolved;
            }
            catch (error) {
                logger.emit('devtools-connect:resolve-srv-error', { from: uri, error, duringLoad: false, resolutionDetails });
                throw error;
            }
        }
    }
    return uri;
}
function detectAndLogMissingOptionalDependencies(logger) {
    try {
        require('saslprep');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'saslprep', error });
    }
    try {
        require('mongodb-client-encryption');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'mongodb-client-encryption', error });
    }
    try {
        require('os-dns-native');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'os-dns-native', error });
    }
    try {
        require('resolve-mongodb-srv');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'resolve-mongodb-srv', error });
    }
    try {
        require('kerberos');
    }
    catch (error) {
        logger.emit('devtools-connect:missing-optional-dependency', { name: 'kerberos', error });
    }
}
async function connectMongoClient(uri, clientOptions, logger, MongoClientClass) {
    var _a, _b;
    detectAndLogMissingOptionalDependencies(logger);
    if (clientOptions.autoEncryption !== undefined &&
        !clientOptions.autoEncryption.bypassAutoEncryption) {
        const optionsWithoutFLE = { ...clientOptions };
        delete optionsWithoutFLE.autoEncryption;
        delete optionsWithoutFLE.serverApi;
        const client = new MongoClientClass(uri, optionsWithoutFLE);
        await connectWithFailFast(uri, client, logger);
        const buildInfo = await client.db('admin').admin().command({ buildInfo: 1 });
        await client.close();
        if (!((_a = buildInfo.modules) === null || _a === void 0 ? void 0 : _a.includes('enterprise')) &&
            !((_b = buildInfo.gitVersion) === null || _b === void 0 ? void 0 : _b.match(/enterprise/))) {
            throw new MongoAutoencryptionUnavailable();
        }
    }
    uri = await resolveMongodbSrv(uri, logger);
    const client = new MongoClientClass(uri, clientOptions);
    await connectWithFailFast(uri, client, logger);
    return client;
}
exports.connectMongoClient = connectMongoClient;
//# sourceMappingURL=connect.js.map
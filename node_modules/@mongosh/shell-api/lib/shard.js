"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const helpers_1 = require("./helpers");
const enums_1 = require("./enums");
const result_1 = require("./result");
const history_1 = require("@mongosh/history");
let Shard = class Shard extends decorators_1.ShellApiWithMongoClass {
    constructor(database) {
        super();
        this._database = database;
    }
    get _mongo() {
        return this._database._mongo;
    }
    [enums_1.asPrintable]() {
        return `Shard class connected to ${history_1.redactURICredentials(this._database._mongo._uri)} via db ${this._database._name}`;
    }
    _emitShardApiCall(methodName, methodArguments = {}) {
        this._database._mongo._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Shard',
            arguments: methodArguments
        });
    }
    async enableSharding(database, primaryShard) {
        helpers_1.assertArgsDefinedType([database, primaryShard], ['string', [undefined, 'string']], 'Shard.enableSharding');
        this._emitShardApiCall('enableSharding', { database, primaryShard });
        const cmd = {
            enableSharding: database
        };
        if (primaryShard !== undefined) {
            cmd.primaryShard = primaryShard;
        }
        try {
            return await this._database._runAdminCommand(cmd);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. Are you connected to mongos?`;
            }
            throw error;
        }
    }
    async commitReshardCollection(namespace) {
        helpers_1.assertArgsDefinedType([namespace], ['string'], 'Shard.commitReshardCollection');
        this._emitShardApiCall('commitReshardCollection', { namespace });
        return await this._database._runAdminCommand({
            commitReshardCollection: namespace
        });
    }
    async abortReshardCollection(namespace) {
        helpers_1.assertArgsDefinedType([namespace], ['string'], 'Shard.abortReshardCollection');
        this._emitShardApiCall('abortReshardCollection', { namespace });
        return await this._database._runAdminCommand({
            abortReshardCollection: namespace
        });
    }
    async shardCollection(namespace, key, unique, options) {
        return await this._runShardCollection('shardCollection', namespace, key, unique, options);
    }
    async reshardCollection(namespace, key, unique, options) {
        return await this._runShardCollection('reshardCollection', namespace, key, unique, options);
    }
    async _runShardCollection(command, namespace, key, unique, options) {
        helpers_1.assertArgsDefinedType([namespace, key, unique, options], ['string', 'object', [undefined, 'boolean', 'object'], [undefined, 'object']], `Shard.${command}`);
        this._emitShardApiCall(command, { namespace, key, unique, options });
        if (typeof unique === 'object' && unique !== null) {
            options = unique;
            unique = undefined;
        }
        const cmd = {
            [command]: namespace,
            key: key
        };
        if (unique !== undefined) {
            cmd.unique = unique;
        }
        const orderedCmd = options !== undefined ? { ...cmd, ...options } : cmd;
        try {
            return await this._database._runAdminCommand(orderedCmd);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. Are you connected to mongos?`;
            }
            throw error;
        }
    }
    async status(verbose = false, configDB) {
        const result = await helpers_1.getPrintableShardStatus(configDB !== null && configDB !== void 0 ? configDB : await helpers_1.getConfigDB(this._database), verbose);
        return new result_1.CommandResult('StatsResult', result);
    }
    async addShard(url) {
        helpers_1.assertArgsDefinedType([url], ['string'], 'Shard.addShard');
        await helpers_1.getConfigDB(this._database);
        this._emitShardApiCall('addShard', { url });
        return this._database._runAdminCommand({
            addShard: url
        });
    }
    async addShardToZone(shard, zone) {
        helpers_1.assertArgsDefinedType([shard, zone], ['string', 'string'], 'Shard.addShardToZone');
        this._emitShardApiCall('addShardToZone', { shard, zone });
        await helpers_1.getConfigDB(this._database);
        return this._database._runAdminCommand({
            addShardToZone: shard,
            zone: zone
        });
    }
    async addShardTag(shard, tag) {
        helpers_1.assertArgsDefinedType([shard, tag], ['string', 'string'], 'Shard.addShardTag');
        this._emitShardApiCall('addShardTag', { shard, tag });
        try {
            return await this.addShardToZone(shard, tag);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to addShardToZone which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async updateZoneKeyRange(namespace, min, max, zone) {
        helpers_1.assertArgsDefinedType([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.updateZoneKeyRange');
        this._emitShardApiCall('updateZoneKeyRange', { namespace, min, max, zone });
        await helpers_1.getConfigDB(this._database);
        return await this._database._runAdminCommand({
            updateZoneKeyRange: namespace,
            min,
            max,
            zone
        });
    }
    async addTagRange(namespace, min, max, zone) {
        helpers_1.assertArgsDefinedType([namespace, min, max, zone], ['string', 'object', 'object', true], 'Shard.addTagRange');
        this._emitShardApiCall('addTagRange', { namespace, min, max, zone });
        try {
            return await this.updateZoneKeyRange(namespace, min, max, zone);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async removeRangeFromZone(ns, min, max) {
        helpers_1.assertArgsDefinedType([ns, min, max], ['string', 'object', 'object'], 'Shard.removeRangeFromZone');
        this._emitShardApiCall('removeRangeFromZone', { ns, min, max });
        return this.updateZoneKeyRange(ns, min, max, null);
    }
    async removeTagRange(ns, min, max) {
        helpers_1.assertArgsDefinedType([ns, min, max], ['string', 'object', 'object'], 'Shard.removeTagRange');
        this._emitShardApiCall('removeTagRange', { ns, min, max });
        try {
            return await this.updateZoneKeyRange(ns, min, max, null);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to updateZoneKeyRange which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async removeShardFromZone(shard, zone) {
        helpers_1.assertArgsDefinedType([shard, zone], ['string', 'string'], 'Shard.removeShardFromZone');
        this._emitShardApiCall('removeShardFromZone', { shard, zone });
        await helpers_1.getConfigDB(this._database);
        return await this._database._runAdminCommand({
            removeShardFromZone: shard,
            zone: zone
        });
    }
    async removeShardTag(shard, tag) {
        helpers_1.assertArgsDefinedType([shard, tag], ['string', 'string'], 'Shard.removeShardTag');
        this._emitShardApiCall('removeTagRange', { shard, tag });
        try {
            return await this.removeShardFromZone(shard, tag);
        }
        catch (error) {
            if (error.codeName === 'CommandNotFound') {
                error.message = `${error.message}. This method aliases to removeShardFromZone which exists only for server versions > 3.4.`;
            }
            throw error;
        }
    }
    async enableAutoSplit() {
        this._emitShardApiCall('enableAutoSplit', {});
        const config = await helpers_1.getConfigDB(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'autosplit' }, { $set: { enabled: true } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async disableAutoSplit() {
        this._emitShardApiCall('disableAutoSplit', {});
        const config = await helpers_1.getConfigDB(this._database);
        return await config.getCollection('settings').updateOne({ _id: 'autosplit' }, { $set: { enabled: false } }, { upsert: true, writeConcern: { w: 'majority', wtimeout: 30000 } });
    }
    async splitAt(ns, query) {
        helpers_1.assertArgsDefinedType([ns, query], ['string', 'object'], 'Shard.splitAt');
        this._emitShardApiCall('splitAt', { ns, query });
        return this._database._runAdminCommand({
            split: ns,
            middle: query
        });
    }
    async splitFind(ns, query) {
        helpers_1.assertArgsDefinedType([ns, query], ['string', 'object'], 'Shard.splitFind');
        this._emitShardApiCall('splitFind', { ns, query });
        return this._database._runAdminCommand({
            split: ns,
            find: query
        });
    }
    async moveChunk(ns, query, destination) {
        helpers_1.assertArgsDefinedType([ns, query, destination], ['string', 'object', 'string'], 'Shard.moveChunk');
        this._emitShardApiCall('moveChunk', { ns, query, destination });
        return this._database._runAdminCommand({
            moveChunk: ns,
            find: query,
            to: destination
        });
    }
    async balancerCollectionStatus(ns) {
        helpers_1.assertArgsDefinedType([ns], ['string'], 'Shard.balancerCollectionStatus');
        this._emitShardApiCall('balancerCollectionStatus', { ns });
        return this._database._runAdminCommand({
            balancerCollectionStatus: ns
        });
    }
    async enableBalancing(ns) {
        helpers_1.assertArgsDefinedType([ns], ['string'], 'Shard.enableBalancing');
        this._emitShardApiCall('enableBalancing', { ns });
        const config = await helpers_1.getConfigDB(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $set: { 'noBalance': false } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async disableBalancing(ns) {
        helpers_1.assertArgsDefinedType([ns], ['string'], 'Shard.disableBalancing');
        this._emitShardApiCall('disableBalancing', { ns });
        const config = await helpers_1.getConfigDB(this._database);
        return await config.getCollection('collections').updateOne({ _id: ns }, { $set: { 'noBalance': true } }, { writeConcern: { w: 'majority', wtimeout: 60000 } });
    }
    async getBalancerState() {
        this._emitShardApiCall('getBalancerState', {});
        const config = await helpers_1.getConfigDB(this._database);
        const doc = await config.getCollection('settings').findOne({ _id: 'balancer' });
        if (doc === null || doc === undefined) {
            return true;
        }
        return !doc.stopped;
    }
    async isBalancerRunning() {
        this._emitShardApiCall('isBalancerRunning', {});
        await helpers_1.getConfigDB(this._database);
        return this._database._runAdminCommand({
            balancerStatus: 1
        });
    }
    async startBalancer(timeout = 60000) {
        helpers_1.assertArgsDefinedType([timeout], ['number'], 'Shard.startBalancer');
        this._emitShardApiCall('startBalancer', { timeout });
        return this._database._runAdminCommand({
            balancerStart: 1, maxTimeMS: timeout
        });
    }
    async stopBalancer(timeout = 60000) {
        helpers_1.assertArgsDefinedType([timeout], ['number'], 'Shard.stopBalancer');
        this._emitShardApiCall('stopBalancer', { timeout });
        return this._database._runAdminCommand({
            balancerStop: 1, maxTimeMS: timeout
        });
    }
    async setBalancerState(state) {
        helpers_1.assertArgsDefinedType([state], ['boolean'], 'Shard.setBalancerState');
        this._emitShardApiCall('setBalancerState', { state });
        if (state) {
            return this.startBalancer();
        }
        return this.stopBalancer();
    }
};
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "enableSharding", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "commitReshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "abortReshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "shardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['5.0.0', enums_1.ServerVersions.latest])
], Shard.prototype, "reshardCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Shard.prototype, "status", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "addShard", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addShardToZone", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addShardTag", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "updateZoneKeyRange", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "addTagRange", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeRangeFromZone", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeTagRange", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeShardFromZone", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "removeShardTag", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "enableAutoSplit", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1]),
    decorators_1.serverVersions(['3.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "disableAutoSplit", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "splitAt", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "splitFind", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "moveChunk", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([]),
    decorators_1.serverVersions(['4.4.0', enums_1.ServerVersions.latest])
], Shard.prototype, "balancerCollectionStatus", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "enableBalancing", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "disableBalancing", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "getBalancerState", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "isBalancerRunning", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "startBalancer", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "stopBalancer", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Shard.prototype, "setBalancerState", null);
Shard = __decorate([
    decorators_1.shellApiClassDefault
], Shard);
exports.default = Shard;
//# sourceMappingURL=shard.js.map
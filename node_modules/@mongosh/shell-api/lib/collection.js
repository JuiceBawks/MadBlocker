"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const helpers_1 = require("./helpers");
const index_1 = require("./index");
const errors_1 = require("@mongosh/errors");
const bulk_1 = __importDefault(require("./bulk"));
const history_1 = require("@mongosh/history");
const plan_cache_1 = __importDefault(require("./plan-cache"));
const change_stream_cursor_1 = __importDefault(require("./change-stream-cursor"));
const error_codes_1 = require("./error-codes");
let Collection = class Collection extends decorators_1.ShellApiWithMongoClass {
    constructor(mongo, database, name) {
        super();
        this._mongo = mongo;
        this._database = database;
        this._name = name;
        const proxy = new Proxy(this, {
            get: (target, prop) => {
                if (prop in target) {
                    return target[prop];
                }
                if (typeof prop !== 'string' ||
                    prop.startsWith('_') ||
                    !helpers_1.isValidCollectionName(prop)) {
                    return;
                }
                return database.getCollection(`${name}.${prop}`);
            }
        });
        return proxy;
    }
    [enums_1.namespaceInfo]() {
        return { db: this._database.getName(), collection: this._name };
    }
    [enums_1.asPrintable]() {
        return `${this._database.getName()}.${this._name}`;
    }
    _emitCollectionApiCall(methodName, methodArguments = {}) {
        this._mongo._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Collection',
            db: this._database._name,
            coll: this._name,
            arguments: methodArguments
        });
    }
    async aggregate(...args) {
        let options;
        let pipeline;
        if (args.length === 0 || Array.isArray(args[0])) {
            options = args[1] || {};
            pipeline = args[0] || [];
        }
        else {
            options = {};
            pipeline = args || [];
        }
        this._emitCollectionApiCall('aggregate', { options, pipeline });
        const { aggOptions, dbOptions, explain } = helpers_1.adaptAggregateOptions(options);
        const providerCursor = this._mongo._serviceProvider.aggregate(this._database._name, this._name, pipeline, { ...await this._database._baseOptions(), ...aggOptions }, dbOptions);
        const cursor = new index_1.AggregationCursor(this._mongo, providerCursor);
        if (explain) {
            return await cursor.explain(explain);
        }
        else if (helpers_1.shouldRunAggregationImmediately(pipeline)) {
            await cursor.hasNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async bulkWrite(operations, options = {}) {
        this._emitCollectionApiCall('bulkWrite', { options });
        const result = await this._mongo._serviceProvider.bulkWrite(this._database._name, this._name, operations, { ...await this._database._baseOptions(), ...options });
        return new index_1.BulkWriteResult(!!result.ok, result.insertedCount, result.insertedIds, result.matchedCount, result.modifiedCount, result.deletedCount, result.upsertedCount, result.upsertedIds);
    }
    async count(query = {}, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.count() is deprecated. Use countDocuments or estimatedDocumentCount.');
        this._emitCollectionApiCall('count', { query, options });
        return this._mongo._serviceProvider.count(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options });
    }
    async countDocuments(query, options = {}) {
        this._emitCollectionApiCall('countDocuments', { query, options });
        return this._mongo._serviceProvider.countDocuments(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options });
    }
    async deleteMany(filter, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.deleteMany');
        this._emitCollectionApiCall('deleteMany', { filter, options });
        const result = await this._mongo._serviceProvider.deleteMany(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    async deleteOne(filter, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.deleteOne');
        this._emitCollectionApiCall('deleteOne', { filter, options });
        const result = await this._mongo._serviceProvider.deleteOne(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    async distinct(field, query, options = {}) {
        this._emitCollectionApiCall('distinct', { field, query, options });
        return helpers_1.maybeMarkAsExplainOutput(await this._mongo._serviceProvider.distinct(this._database._name, this._name, field, query, { ...await this._database._baseOptions(), ...options }), options);
    }
    async estimatedDocumentCount(options = {}) {
        this._emitCollectionApiCall('estimatedDocumentCount', { options });
        return this._mongo._serviceProvider.estimatedDocumentCount(this._database._name, this._name, { ...await this._database._baseOptions(), ...options });
    }
    async find(query, projection, options = {}) {
        if (projection) {
            options.projection = projection;
        }
        this._emitCollectionApiCall('find', { query, options });
        const cursor = new index_1.Cursor(this._mongo, this._mongo._serviceProvider.find(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options }));
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async findAndModify(options) {
        helpers_1.assertArgsDefinedType([options], [true], 'Collection.findAndModify');
        helpers_1.assertKeysDefined(options, ['query']);
        this._emitCollectionApiCall('findAndModify', { options: { ...options, update: !!options.update } });
        const reducedOptions = { ...options };
        delete reducedOptions.query;
        delete reducedOptions.update;
        if (options.remove) {
            return this.findOneAndDelete(options.query, reducedOptions);
        }
        const { update } = options;
        if (!update) {
            throw new errors_1.MongoshInvalidInputError('Must specify options.update or options.remove', errors_1.CommonErrors.InvalidArgument);
        }
        if (Array.isArray(update) || Object.keys(update).some(key => key.startsWith('$'))) {
            return this.findOneAndUpdate(options.query, update, reducedOptions);
        }
        return this.findOneAndReplace(options.query, update, reducedOptions);
    }
    async findOne(query = {}, projection, options = {}) {
        if (projection) {
            options.projection = projection;
        }
        this._emitCollectionApiCall('findOne', { query, options });
        return new index_1.Cursor(this._mongo, this._mongo._serviceProvider.find(this._database._name, this._name, query, { ...await this._database._baseOptions(), ...options })).limit(1).tryNext();
    }
    async renameCollection(newName, dropTarget) {
        helpers_1.assertArgsDefinedType([newName], ['string'], 'Collection.renameCollection');
        this._emitCollectionApiCall('renameCollection', { newName, dropTarget });
        try {
            await this._mongo._serviceProvider.renameCollection(this._database._name, this._name, newName, { ...await this._database._baseOptions(), dropTarget: !!dropTarget });
            return {
                ok: 1
            };
        }
        catch (e) {
            if (e.name === 'MongoError') {
                return {
                    ok: 0,
                    errmsg: e.errmsg,
                    code: e.code,
                    codeName: e.codeName
                };
            }
            throw e;
        }
    }
    async findOneAndDelete(filter, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.findOneAndDelete');
        this._emitCollectionApiCall('findOneAndDelete', { filter, options });
        const result = await this._mongo._serviceProvider.findOneAndDelete(this._database._name, this._name, filter, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return result.value;
    }
    async findOneAndReplace(filter, replacement, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.findOneAndReplace');
        const findOneAndReplaceOptions = helpers_1.processFindAndModifyOptions({
            ...await this._database._baseOptions(),
            ...options
        });
        this._emitCollectionApiCall('findOneAndReplace', { filter, findOneAndReplaceOptions });
        const result = await this._mongo._serviceProvider.findOneAndReplace(this._database._name, this._name, filter, replacement, findOneAndReplaceOptions);
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return result.value;
    }
    async findOneAndUpdate(filter, update, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.findOneAndUpdate');
        const findOneAndUpdateOptions = helpers_1.processFindAndModifyOptions({
            ...await this._database._baseOptions(),
            ...options
        });
        this._emitCollectionApiCall('findOneAndUpdate', { filter, findOneAndUpdateOptions });
        const result = await this._mongo._serviceProvider.findOneAndUpdate(this._database._name, this._name, filter, update, findOneAndUpdateOptions);
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return result.value;
    }
    async insert(docs, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.insert() is deprecated. Use insertOne, insertMany, or bulkWrite.');
        helpers_1.assertArgsDefinedType([docs], [true], 'Collection.insert');
        const docsToInsert = Array.isArray(docs) ? docs.map((doc) => ({ ...doc })) : [{ ...docs }];
        this._emitCollectionApiCall('insert', { options });
        const result = await this._mongo._serviceProvider.insertMany(this._database._name, this._name, docsToInsert, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertManyResult(!!result.acknowledged, result.insertedIds);
    }
    async insertMany(docs, options = {}) {
        helpers_1.assertArgsDefinedType([docs], [true], 'Collection.insertMany');
        const docsToInsert = Array.isArray(docs) ? docs.map((doc) => ({ ...doc })) : docs;
        this._emitCollectionApiCall('insertMany', { options });
        const result = await this._mongo._serviceProvider.insertMany(this._database._name, this._name, docsToInsert, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertManyResult(!!result.acknowledged, result.insertedIds);
    }
    async insertOne(doc, options = {}) {
        helpers_1.assertArgsDefinedType([doc], [true], 'Collection.insertOne');
        this._emitCollectionApiCall('insertOne', { options });
        const result = await this._mongo._serviceProvider.insertOne(this._database._name, this._name, { ...doc }, { ...await this._database._baseOptions(), ...options });
        return new index_1.InsertOneResult(!!result.acknowledged, result.insertedId);
    }
    async isCapped() {
        this._emitCollectionApiCall('isCapped');
        return this._mongo._serviceProvider.isCapped(this._database._name, this._name);
    }
    async remove(query, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.remove() is deprecated. Use deleteOne, deleteMany, findOneAndDelete, or bulkWrite.');
        helpers_1.assertArgsDefinedType([query], [true], 'Collection.remove');
        const removeOptions = helpers_1.processRemoveOptions(options);
        const method = removeOptions.justOne ? 'deleteOne' : 'deleteMany';
        delete removeOptions.justOne;
        this._emitCollectionApiCall('remove', { query, removeOptions });
        const result = await this._mongo._serviceProvider[method](this._database._name, this._name, query, { ...await this._database._baseOptions(), ...removeOptions });
        if (removeOptions.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.DeleteResult(!!result.acknowledged, result.deletedCount);
    }
    save() {
        throw new errors_1.MongoshInvalidInputError('Collection.save() is deprecated. Use insertOne, insertMany, updateOne, or updateMany.');
    }
    async replaceOne(filter, replacement, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.replaceOne');
        this._emitCollectionApiCall('replaceOne', { filter, options });
        const result = await this._mongo._serviceProvider.replaceOne(this._database._name, this._name, filter, replacement, { ...await this._database._baseOptions(), ...options });
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async update(filter, update, options = {}) {
        await this._instanceState.printDeprecationWarning('Collection.update() is deprecated. Use updateOne, updateMany, or bulkWrite.');
        helpers_1.assertArgsDefinedType([filter, update], [true, true], 'Collection.update');
        this._emitCollectionApiCall('update', { filter, options });
        let result;
        if (options.multi) {
            result = await this._mongo._serviceProvider.updateMany(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        }
        else {
            result = await this._mongo._serviceProvider.updateOne(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        }
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async updateMany(filter, update, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.updateMany');
        this._emitCollectionApiCall('updateMany', { filter, options });
        const result = await this._mongo._serviceProvider.updateMany(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async updateOne(filter, update, options = {}) {
        helpers_1.assertArgsDefinedType([filter], [true], 'Collection.updateOne');
        this._emitCollectionApiCall('updateOne', { filter, options });
        const result = await this._mongo._serviceProvider.updateOne(this._database._name, this._name, filter, update, { ...await this._database._baseOptions(), ...options });
        if (options.explain) {
            return helpers_1.markAsExplainOutput(result);
        }
        return new index_1.UpdateResult(!!result.acknowledged, result.matchedCount, result.modifiedCount, result.upsertedCount, result.upsertedId);
    }
    async convertToCapped(size) {
        this._emitCollectionApiCall('convertToCapped', { size });
        return await this._database._runCommand({
            convertToCapped: this._name,
            size
        });
    }
    async createIndexes(keyPatterns, options = {}) {
        helpers_1.assertArgsDefinedType([keyPatterns], [true], 'Collection.createIndexes');
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new errors_1.MongoshInvalidInputError('The "options" argument must be an object.', errors_1.CommonErrors.InvalidArgument);
        }
        const specs = keyPatterns.map((pattern) => ({
            ...options, key: pattern
        }));
        this._emitCollectionApiCall('createIndexes', { specs });
        return await this._mongo._serviceProvider.createIndexes(this._database._name, this._name, specs, { ...await this._database._baseOptions(), ...options });
    }
    async createIndex(keys, options = {}) {
        helpers_1.assertArgsDefinedType([keys], [true], 'Collection.createIndex');
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new errors_1.MongoshInvalidInputError('The "options" argument must be an object.', errors_1.CommonErrors.InvalidArgument);
        }
        this._emitCollectionApiCall('createIndex', { keys, options });
        const spec = { key: keys, ...options };
        const names = await this._mongo._serviceProvider.createIndexes(this._database._name, this._name, [spec], { ...await this._database._baseOptions(), ...options });
        if (!Array.isArray(names) || names.length !== 1) {
            throw new errors_1.MongoshInternalError(`Expected createIndexes() to return array of length 1, saw ${names}`);
        }
        return names[0];
    }
    async ensureIndex(keys, options = {}) {
        helpers_1.assertArgsDefinedType([keys], [true], 'Collection.ensureIndex');
        if (typeof options !== 'object' || Array.isArray(options)) {
            throw new errors_1.MongoshInvalidInputError('The "options" argument must be an object.', errors_1.CommonErrors.InvalidArgument);
        }
        this._emitCollectionApiCall('ensureIndex', { keys, options });
        const spec = { key: keys, ...options };
        return await this._mongo._serviceProvider.createIndexes(this._database._name, this._name, [spec], { ...await this._database._baseOptions(), ...options });
    }
    async getIndexes() {
        this._emitCollectionApiCall('getIndexes');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndexSpecs() {
        this._emitCollectionApiCall('getIndexSpecs');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndices() {
        this._emitCollectionApiCall('getIndices');
        return await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
    }
    async getIndexKeys() {
        this._emitCollectionApiCall('getIndexKeys');
        const indexes = await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
        return indexes.map(i => i.key);
    }
    async dropIndexes(indexes = '*') {
        this._emitCollectionApiCall('dropIndexes', { indexes });
        try {
            return await this._database._runCommand({
                dropIndexes: this._name,
                index: indexes,
            });
        }
        catch (error) {
            if ((error.codeName === 'IndexNotFound' || error.codeName === undefined) &&
                (error.errmsg === 'invalid index name spec' || error.errmsg === undefined) &&
                Array.isArray(indexes) &&
                indexes.length > 0 &&
                (await this._database.version()).match(/^4\.0\./)) {
                const all = await Promise.all(indexes.map(async (index) => await this.dropIndexes(index)));
                const errored = all.find(result => !result.ok);
                if (errored)
                    return errored;
                return all.sort((a, b) => b.nIndexesWas - a.nIndexesWas)[0];
            }
            if (error.codeName === 'IndexNotFound') {
                return {
                    ok: error.ok,
                    errmsg: error.errmsg,
                    code: error.code,
                    codeName: error.codeName
                };
            }
            throw error;
        }
    }
    async dropIndex(index) {
        helpers_1.assertArgsDefinedType([index], [true], 'Collection.dropIndex');
        this._emitCollectionApiCall('dropIndex', { index });
        if (index === '*') {
            throw new errors_1.MongoshInvalidInputError('To drop indexes in the collection using \'*\', use db.collection.dropIndexes().', errors_1.CommonErrors.InvalidArgument);
        }
        if (Array.isArray(index)) {
            throw new errors_1.MongoshInvalidInputError('The index to drop must be either the index name or the index specification document.', errors_1.CommonErrors.InvalidArgument);
        }
        return this.dropIndexes(index);
    }
    async totalIndexSize(...args) {
        this._emitCollectionApiCall('totalIndexSize');
        if (args.length) {
            throw new errors_1.MongoshInvalidInputError('"totalIndexSize" takes no argument. Use db.collection.stats to get detailed information.', errors_1.CommonErrors.InvalidArgument);
        }
        const stats = await this._mongo._serviceProvider.stats(this._database._name, this._name, await this._database._baseOptions());
        return stats.totalIndexSize;
    }
    async reIndex() {
        this._emitCollectionApiCall('reIndex');
        return await this._database._runCommand({
            reIndex: this._name
        });
    }
    getDB() {
        this._emitCollectionApiCall('getDB');
        return this._database;
    }
    getMongo() {
        this._emitCollectionApiCall('getMongo');
        return this._mongo;
    }
    async dataSize() {
        this._emitCollectionApiCall('dataSize');
        const stats = await this._mongo._serviceProvider.stats(this._database._name, this._name, await this._database._baseOptions());
        return stats.size;
    }
    async storageSize() {
        this._emitCollectionApiCall('storageSize');
        const stats = await this._mongo._serviceProvider.stats(this._database._name, this._name, await this._database._baseOptions());
        return stats.storageSize;
    }
    async totalSize() {
        this._emitCollectionApiCall('totalSize');
        const stats = await this._mongo._serviceProvider.stats(this._database._name, this._name, await this._database._baseOptions());
        return (stats.storageSize || 0) + (stats.totalIndexSize || 0);
    }
    async drop() {
        this._emitCollectionApiCall('drop');
        try {
            return await this._mongo._serviceProvider.dropCollection(this._database._name, this._name, await this._database._baseOptions());
        }
        catch (error) {
            if (error.codeName === 'NamespaceNotFound') {
                this._mongo._instanceState.messageBus.emit('mongosh:warn', {
                    method: 'drop',
                    class: 'Collection',
                    message: `Namespace not found: ${this._name}`
                });
                return false;
            }
            throw error;
        }
    }
    async exists() {
        this._emitCollectionApiCall('exists');
        const collectionInfos = await this._mongo._serviceProvider.listCollections(this._database._name, {
            name: this._name
        }, await this._database._baseOptions());
        return collectionInfos[0] || null;
    }
    getFullName() {
        this._emitCollectionApiCall('getFullName');
        return `${this._database._name}.${this._name}`;
    }
    getName() {
        this._emitCollectionApiCall('getName');
        return `${this._name}`;
    }
    async runCommand(commandName, options) {
        helpers_1.assertArgsDefinedType([commandName], [['string', 'object']], 'Collection.runCommand');
        if (options) {
            if (typeof commandName !== 'string') {
                throw new errors_1.MongoshInvalidInputError('Collection.runCommand takes a command string as its first arugment', errors_1.CommonErrors.InvalidArgument);
            }
            else if (commandName in options) {
                throw new errors_1.MongoshInvalidInputError('The "commandName" argument cannot be passed as an option to "runCommand".', errors_1.CommonErrors.InvalidArgument);
            }
        }
        const hiddenCommands = new RegExp(history_1.HIDDEN_COMMANDS);
        if (typeof commandName === 'string' && !hiddenCommands.test(commandName)) {
            this._emitCollectionApiCall('runCommand', { commandName });
        }
        const cmd = typeof commandName === 'string' ? {
            [commandName]: this._name,
            ...options
        } : commandName;
        return await this._database._runCommand(cmd);
    }
    explain(verbosity = 'queryPlanner') {
        verbosity = helpers_1.validateExplainableVerbosity(verbosity);
        this._emitCollectionApiCall('explain', { verbosity });
        return new index_1.Explainable(this._mongo, this, verbosity);
    }
    async stats(originalOptions = {}) {
        var _a;
        const options = typeof originalOptions === 'number' ? { scale: originalOptions } : originalOptions;
        if (options.indexDetailsKey && options.indexDetailsName) {
            throw new errors_1.MongoshInvalidInputError('Cannot filter indexDetails on both indexDetailsKey and indexDetailsName', errors_1.CommonErrors.InvalidArgument);
        }
        if (options.indexDetailsKey && typeof options.indexDetailsKey !== 'object') {
            throw new errors_1.MongoshInvalidInputError(`Expected options.indexDetailsKey to be a document, got ${typeof options.indexDetailsKey}`, errors_1.CommonErrors.InvalidArgument);
        }
        if (options.indexDetailsName && typeof options.indexDetailsName !== 'string') {
            throw new errors_1.MongoshInvalidInputError(`Expected options.indexDetailsName to be a string, got ${typeof options.indexDetailsName}`, errors_1.CommonErrors.InvalidArgument);
        }
        options.scale = options.scale || 1;
        options.indexDetails = options.indexDetails || false;
        this._emitCollectionApiCall('stats', { options });
        const result = await this._database._runCommand({
            collStats: this._name, scale: options.scale
        });
        if (!result) {
            throw new errors_1.MongoshRuntimeError(`Error running collStats command on ${this.getFullName()}`, errors_1.CommonErrors.CommandFailed);
        }
        let filterIndexName = options.indexDetailsName;
        if (!filterIndexName && options.indexDetailsKey) {
            const indexes = await this._mongo._serviceProvider.getIndexes(this._database._name, this._name, await this._database._baseOptions());
            indexes.forEach((spec) => {
                if (JSON.stringify(spec.key) === JSON.stringify(options.indexDetailsKey)) {
                    filterIndexName = spec.name;
                }
            });
        }
        const updateStats = (stats) => {
            if (!stats.indexDetails) {
                return;
            }
            if (!options.indexDetails) {
                delete stats.indexDetails;
                return;
            }
            if (!filterIndexName) {
                return;
            }
            for (const key of Object.keys(stats.indexDetails)) {
                if (key === filterIndexName) {
                    continue;
                }
                delete stats.indexDetails[key];
            }
        };
        updateStats(result);
        for (const shardName of Object.keys((_a = result.shards) !== null && _a !== void 0 ? _a : {})) {
            updateStats(result.shards[shardName]);
        }
        return result;
    }
    async latencyStats(options = {}) {
        this._emitCollectionApiCall('latencyStats', { options });
        const pipeline = [{ $collStats: { latencyStats: options } }];
        const providerCursor = this._mongo._serviceProvider.aggregate(this._database._name, this._name, pipeline, await this._database._baseOptions());
        return await providerCursor.toArray();
    }
    async initializeOrderedBulkOp() {
        this._emitCollectionApiCall('initializeOrderedBulkOp');
        const innerBulk = await this._mongo._serviceProvider.initializeBulkOp(this._database._name, this._name, true, await this._database._baseOptions());
        return new bulk_1.default(this, innerBulk, true);
    }
    async initializeUnorderedBulkOp() {
        this._emitCollectionApiCall('initializeUnorderedBulkOp');
        const innerBulk = await this._mongo._serviceProvider.initializeBulkOp(this._database._name, this._name, false, await this._database._baseOptions());
        return new bulk_1.default(this, innerBulk);
    }
    getPlanCache() {
        this._emitCollectionApiCall('getPlanCache');
        return new plan_cache_1.default(this);
    }
    async mapReduce(map, reduce, optionsOrOutString) {
        await this._instanceState.printDeprecationWarning('Collection.mapReduce() is deprecated. Use an aggregation instead.\nSee https://docs.mongodb.com/manual/core/map-reduce for details.');
        helpers_1.assertArgsDefinedType([map, reduce, optionsOrOutString], [true, true, true], 'Collection.mapReduce');
        this._emitCollectionApiCall('mapReduce', { map, reduce, out: optionsOrOutString });
        let cmd = {
            mapReduce: this._name,
            map: map,
            reduce: reduce,
            ...helpers_1.processMapReduceOptions(optionsOrOutString)
        };
        if (cmd.explain) {
            const verbosity = cmd.explain;
            delete cmd.explain;
            cmd = {
                explain: cmd,
                verbosity
            };
        }
        return await this._database._runCommand(cmd);
    }
    async validate(options = false) {
        this._emitCollectionApiCall('validate', { options });
        if (typeof options === 'boolean') {
            options = { full: options };
        }
        return await this._database._runCommand({
            validate: this._name,
            ...options
        });
    }
    async getShardVersion() {
        this._emitCollectionApiCall('getShardVersion', {});
        return await this._database._runAdminCommand({
            getShardVersion: `${this._database._name}.${this._name}`
        });
    }
    async getShardDistribution() {
        var _a;
        this._emitCollectionApiCall('getShardDistribution', {});
        const result = {};
        const config = this._mongo.getDB('config');
        const ns = `${this._database._name}.${this._name}`;
        const configCollectionsInfo = await config.getCollection('collections').findOne({
            _id: ns,
            dropped: { $ne: true }
        });
        if (!configCollectionsInfo) {
            throw new errors_1.MongoshInvalidInputError(`Collection ${this._name} is not sharded`, error_codes_1.ShellApiErrors.NotConnectedToShardedCluster);
        }
        const collStats = await (await this.aggregate({ '$collStats': { storageStats: {} } })).toArray();
        const uuid = (_a = configCollectionsInfo === null || configCollectionsInfo === void 0 ? void 0 : configCollectionsInfo.uuid) !== null && _a !== void 0 ? _a : null;
        const totals = { numChunks: 0, size: 0, count: 0 };
        const conciseShardsStats = [];
        await Promise.all(collStats.map((extShardStats) => ((async () => {
            const { shard } = extShardStats;
            const countChunksQuery = uuid ? { $or: [{ uuid }, { ns }], shard } : { ns, shard };
            const [host, numChunks] = await Promise.all([
                config.getCollection('shards').findOne({ _id: extShardStats.shard }),
                config.getCollection('chunks').countDocuments(countChunksQuery)
            ]);
            const shardStats = {
                shardId: shard,
                host: host !== null ? host.host : null,
                size: extShardStats.storageStats.size,
                count: extShardStats.storageStats.count,
                numChunks: numChunks,
                avgObjSize: extShardStats.storageStats.avgObjSize
            };
            const key = `Shard ${shardStats.shardId} at ${shardStats.host}`;
            const estChunkData = (shardStats.numChunks === 0) ? 0 : (shardStats.size / shardStats.numChunks);
            const estChunkCount = (shardStats.numChunks === 0) ? 0 : Math.floor(shardStats.count / shardStats.numChunks);
            result[key] = {
                data: helpers_1.dataFormat(shardStats.size),
                docs: shardStats.count,
                chunks: shardStats.numChunks,
                'estimated data per chunk': helpers_1.dataFormat(estChunkData),
                'estimated docs per chunk': estChunkCount
            };
            totals.size += shardStats.size;
            totals.count += shardStats.count;
            totals.numChunks += shardStats.numChunks;
            conciseShardsStats.push(shardStats);
        })())));
        const totalValue = {
            data: helpers_1.dataFormat(totals.size),
            docs: totals.count,
            chunks: totals.numChunks
        };
        for (const shardStats of conciseShardsStats) {
            const estDataPercent = (totals.size === 0) ? 0 : (Math.floor(shardStats.size / totals.size * 10000) / 100);
            const estDocPercent = (totals.count === 0) ? 0 : (Math.floor(shardStats.count / totals.count * 10000) / 100);
            totalValue[`Shard ${shardStats.shardId}`] = [
                `${estDataPercent} % data`,
                `${estDocPercent} % docs in cluster`,
                `${helpers_1.dataFormat(shardStats.avgObjSize)} avg obj size on shard`
            ];
        }
        result.Totals = totalValue;
        return new index_1.CommandResult('StatsResult', result);
    }
    async watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        this._emitCollectionApiCall('watch', { pipeline, options });
        const cursor = new change_stream_cursor_1.default(this._mongo._serviceProvider.watch(pipeline, {
            ...await this._database._baseOptions(),
            ...options
        }, {}, this._database._name, this._name), this._name, this._mongo);
        if (!options.resumeAfter && !options.startAfter && !options.startAtOperationTime) {
            await cursor.tryNext();
        }
        this._mongo._instanceState.currentCursor = cursor;
        return cursor;
    }
    async hideIndex(index) {
        this._emitCollectionApiCall('hideIndex');
        return helpers_1.setHideIndex(this, index, true);
    }
    async unhideIndex(index) {
        this._emitCollectionApiCall('unhideIndex');
        return helpers_1.setHideIndex(this, index, false);
    }
};
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('AggregationCursor'),
    decorators_1.apiVersions([1])
], Collection.prototype, "aggregate", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "bulkWrite", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.serverVersions([enums_1.ServerVersions.earliest, '4.0.0']),
    decorators_1.apiVersions([])
], Collection.prototype, "count", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['4.0.3', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "countDocuments", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "deleteMany", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "deleteOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "distinct", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['4.0.3', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "estimatedDocumentCount", null);
__decorate([
    decorators_1.returnType('Cursor'),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], Collection.prototype, "find", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.apiVersions([1])
], Collection.prototype, "findAndModify", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Document'),
    decorators_1.apiVersions([1])
], Collection.prototype, "findOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "renameCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Document'),
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "findOneAndDelete", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Document'),
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "findOneAndReplace", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Document'),
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "findOneAndUpdate", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.serverVersions([enums_1.ServerVersions.earliest, '3.6.0']),
    decorators_1.apiVersions([1])
], Collection.prototype, "insert", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "insertMany", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "insertOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "isCapped", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.serverVersions([enums_1.ServerVersions.earliest, '3.2.0']),
    decorators_1.apiVersions([1])
], Collection.prototype, "remove", null);
__decorate([
    decorators_1.deprecated
], Collection.prototype, "save", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "replaceOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.serverVersions([enums_1.ServerVersions.earliest, '3.2.0']),
    decorators_1.apiVersions([1])
], Collection.prototype, "update", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "updateMany", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "updateOne", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "convertToCapped", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "createIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "createIndex", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "ensureIndex", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "getIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "getIndexSpecs", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "getIndices", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.serverVersions(['3.2.0', enums_1.ServerVersions.latest]),
    decorators_1.apiVersions([1])
], Collection.prototype, "getIndexKeys", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "dropIndexes", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "dropIndex", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "totalIndexSize", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.topologies([enums_1.Topologies.Standalone]),
    decorators_1.apiVersions([])
], Collection.prototype, "reIndex", null);
__decorate([
    decorators_1.returnType('Database')
], Collection.prototype, "getDB", null);
__decorate([
    decorators_1.returnType('Mongo')
], Collection.prototype, "getMongo", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "dataSize", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "storageSize", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "totalSize", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "drop", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "exists", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "runCommand", null);
__decorate([
    decorators_1.returnType('Explainable'),
    decorators_1.apiVersions([1])
], Collection.prototype, "explain", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "stats", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "latencyStats", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Bulk'),
    decorators_1.apiVersions([1])
], Collection.prototype, "initializeOrderedBulkOp", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.returnType('Bulk'),
    decorators_1.apiVersions([1])
], Collection.prototype, "initializeUnorderedBulkOp", null);
__decorate([
    decorators_1.returnType('PlanCache'),
    decorators_1.apiVersions([])
], Collection.prototype, "getPlanCache", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.deprecated,
    decorators_1.serverVersions([enums_1.ServerVersions.earliest, '4.9.0']),
    decorators_1.apiVersions([])
], Collection.prototype, "mapReduce", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([])
], Collection.prototype, "validate", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.topologies([enums_1.Topologies.Sharded]),
    decorators_1.apiVersions([])
], Collection.prototype, "getShardVersion", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.topologies([enums_1.Topologies.Sharded]),
    decorators_1.apiVersions([])
], Collection.prototype, "getShardDistribution", null);
__decorate([
    decorators_1.serverVersions(['3.1.0', enums_1.ServerVersions.latest]),
    decorators_1.topologies([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], Collection.prototype, "watch", null);
__decorate([
    decorators_1.serverVersions(['4.4.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "hideIndex", null);
__decorate([
    decorators_1.serverVersions(['4.4.0', enums_1.ServerVersions.latest]),
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Collection.prototype, "unhideIndex", null);
Collection = __decorate([
    decorators_1.shellApiClassDefault,
    decorators_1.addSourceToResults
], Collection);
exports.default = Collection;
//# sourceMappingURL=collection.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.adjustRunCommand = exports.shouldRunAggregationImmediately = exports.isValidCollectionName = exports.isValidDatabaseName = exports.markAsExplainOutput = exports.maybeMarkAsExplainOutput = exports.processFLEOptions = exports.assertCLI = exports.setHideIndex = exports.processMapReduceOptions = exports.processRemoveOptions = exports.processFindAndModifyOptions = exports.iterate = exports.addHiddenDataProperty = exports.tsToSeconds = exports.dataFormat = exports.getConfigDB = exports.getPrintableShardStatus = exports.processDigestPassword = exports.adaptOptions = exports.assertKeysDefined = exports.assertArgsDefinedType = exports.validateExplainableVerbosity = exports.adaptAggregateOptions = void 0;
const errors_1 = require("@mongosh/errors");
const crypto_1 = __importDefault(require("crypto"));
const error_codes_1 = require("./error-codes");
const service_provider_core_1 = require("@mongosh/service-provider-core");
const enums_1 = require("./enums");
const util_1 = require("util");
function adaptAggregateOptions(options = {}) {
    const aggOptions = { ...options };
    const dbOptions = {};
    let explain;
    if ('readConcern' in aggOptions) {
        dbOptions.readConcern = options.readConcern;
        delete aggOptions.readConcern;
    }
    if ('writeConcern' in aggOptions) {
        Object.assign(dbOptions, options.writeConcern);
        delete aggOptions.writeConcern;
    }
    if ('explain' in aggOptions) {
        explain = validateExplainableVerbosity(aggOptions.explain);
        delete aggOptions.explain;
    }
    return { aggOptions, dbOptions, explain };
}
exports.adaptAggregateOptions = adaptAggregateOptions;
function validateExplainableVerbosity(verbosity) {
    if (verbosity === true) {
        verbosity = 'allPlansExecution';
    }
    else if (verbosity === false) {
        verbosity = 'queryPlanner';
    }
    if (typeof verbosity !== 'string') {
        throw new errors_1.MongoshInvalidInputError('verbosity must be a string', errors_1.CommonErrors.InvalidArgument);
    }
    return verbosity;
}
exports.validateExplainableVerbosity = validateExplainableVerbosity;
function getAssertCaller(caller) {
    return caller ? ` (${caller})` : '';
}
function assertArgsDefinedType(args, expectedTypes, func) {
    args.forEach((arg, i) => {
        const expected = expectedTypes[i];
        if (arg === undefined) {
            if (expected !== true && Array.isArray(expected) && expected.includes(undefined)) {
                return;
            }
            throw new errors_1.MongoshInvalidInputError(`Missing required argument at position ${i}${getAssertCaller(func)}`, errors_1.CommonErrors.InvalidArgument);
        }
        else if (expected === true) {
            return;
        }
        const expectedTypesList = typeof expected === 'string' ? [expected] : expected;
        const isExpectedTypeof = expectedTypesList.includes(typeof arg);
        const isExpectedBson = expectedTypesList.includes(`bson:${arg === null || arg === void 0 ? void 0 : arg._bsontype}`);
        if (!isExpectedTypeof && !isExpectedBson) {
            const expectedMsg = expectedTypesList
                .filter(e => e !== undefined)
                .map(e => e === null || e === void 0 ? void 0 : e.replace(/^bson:/, ''))
                .join(' or ');
            throw new errors_1.MongoshInvalidInputError(`Argument at position ${i} must be of type ${expectedMsg}, got ${typeof arg} instead${getAssertCaller(func)}`, errors_1.CommonErrors.InvalidArgument);
        }
    });
}
exports.assertArgsDefinedType = assertArgsDefinedType;
function assertKeysDefined(object, keys) {
    for (const key of keys) {
        if (object[key] === undefined) {
            throw new errors_1.MongoshInvalidInputError(`Missing required property: ${JSON.stringify(key)}`, errors_1.CommonErrors.InvalidArgument);
        }
    }
}
exports.assertKeysDefined = assertKeysDefined;
function adaptOptions(shellToCommand, additions, shellDoc) {
    return Object.keys(shellDoc).reduce((result, shellKey) => {
        if (shellToCommand[shellKey] === null) {
            return result;
        }
        result[shellToCommand[shellKey] || shellKey] = shellDoc[shellKey];
        return result;
    }, additions);
}
exports.adaptOptions = adaptOptions;
function processDigestPassword(username, passwordDigestor, command) {
    if (passwordDigestor === undefined) {
        return {};
    }
    if (passwordDigestor !== 'server' && passwordDigestor !== 'client') {
        throw new errors_1.MongoshInvalidInputError(`Invalid field: passwordDigestor must be 'client' or 'server', got ${passwordDigestor}`, errors_1.CommonErrors.InvalidArgument);
    }
    if (passwordDigestor === 'client') {
        if (typeof command.pwd !== 'string') {
            throw new errors_1.MongoshInvalidInputError(`User passwords must be of type string. Was given password with type ${typeof command.pwd}`, errors_1.CommonErrors.InvalidArgument);
        }
        const hash = crypto_1.default.createHash('md5');
        hash.update(`${username}:mongo:${command.pwd}`);
        const digested = hash.digest('hex');
        return { digestPassword: false, pwd: digested };
    }
    return { digestPassword: true };
}
exports.processDigestPassword = processDigestPassword;
async function getPrintableShardStatus(configDB, verbose) {
    const result = {};
    const mongosColl = configDB.getCollection('mongos');
    const versionColl = configDB.getCollection('version');
    const shardsColl = configDB.getCollection('shards');
    const chunksColl = configDB.getCollection('chunks');
    const settingsColl = configDB.getCollection('settings');
    const changelogColl = configDB.getCollection('changelog');
    const [version, shards, mostRecentMongos] = await Promise.all([
        versionColl.findOne(),
        shardsColl.find().then(cursor => cursor.sort({ _id: 1 }).toArray()),
        mongosColl.find().then(cursor => cursor.sort({ ping: -1 }).limit(1).tryNext())
    ]);
    if (version === null) {
        throw new errors_1.MongoshInvalidInputError('This db does not have sharding enabled. Be sure you are connecting to a mongos from the shell and not to a mongod.', error_codes_1.ShellApiErrors.NotConnectedToMongos);
    }
    result.shardingVersion = version;
    result.shards = shards;
    const mongosActiveThresholdMs = 60000;
    let mostRecentMongosTime = null;
    let mongosAdjective = 'most recently active';
    if (mostRecentMongos !== null) {
        mostRecentMongosTime = mostRecentMongos.ping;
        if (mostRecentMongosTime.getTime() >= Date.now() - mongosActiveThresholdMs) {
            mongosAdjective = 'active';
        }
    }
    mongosAdjective = `${mongosAdjective} mongoses`;
    if (mostRecentMongosTime === null) {
        result[mongosAdjective] = 'none';
    }
    else {
        const recentMongosQuery = {
            ping: {
                $gt: (() => {
                    const d = mostRecentMongosTime;
                    d.setTime(d.getTime() - mongosActiveThresholdMs);
                    return d;
                })()
            }
        };
        if (verbose) {
            result[mongosAdjective] = await (await mongosColl
                .find(recentMongosQuery))
                .sort({ ping: -1 })
                .toArray();
        }
        else {
            result[mongosAdjective] = (await (await mongosColl.aggregate([
                { $match: recentMongosQuery },
                { $group: { _id: '$mongoVersion', num: { $sum: 1 } } },
                { $sort: { num: -1 } }
            ])).toArray()).map((z) => {
                return { [z._id]: z.num };
            });
        }
    }
    const balancerRes = {};
    await Promise.all([
        (async () => {
            const autosplit = await settingsColl.findOne({ _id: 'autosplit' });
            result.autosplit = { 'Currently enabled': autosplit === null || autosplit.enabled ? 'yes' : 'no' };
        })(),
        (async () => {
            const balancerEnabled = await settingsColl.findOne({ _id: 'balancer' });
            balancerRes['Currently enabled'] = balancerEnabled === null || !balancerEnabled.stopped ? 'yes' : 'no';
        })(),
        (async () => {
            let balancerRunning = 'unknown';
            try {
                const balancerStatus = await configDB.adminCommand({ balancerStatus: 1 });
                balancerRunning = balancerStatus.inBalancerRound ? 'yes' : 'no';
            }
            catch (err) {
            }
            balancerRes['Currently running'] = balancerRunning;
        })(),
        (async () => {
            const settings = await settingsColl.findOne({ _id: 'balancer' });
            if (settings !== null && settings.hasOwnProperty('activeWindow')) {
                const balSettings = settings.activeWindow;
                balancerRes['Balancer active window is set between'] = `${balSettings.start} and ${balSettings.stop} server local time`;
            }
        })(),
        (async () => {
            const activeLocks = await (await configDB.getCollection('locks').find({ state: { $eq: 2 } })).toArray();
            if ((activeLocks === null || activeLocks === void 0 ? void 0 : activeLocks.length) > 0) {
                balancerRes['Collections with active migrations'] = activeLocks.map((lock) => {
                    return `${lock._id} started at ${lock.when}`;
                });
            }
        })(),
        (async () => {
            let versionHasActionlog = false;
            const metaDataVersion = version.currentVersion;
            if (metaDataVersion > 5) {
                versionHasActionlog = true;
            }
            if (metaDataVersion === 5) {
                const verArray = (await configDB.serverBuildInfo()).versionArray;
                if (verArray[0] === 2 && verArray[1] > 6) {
                    versionHasActionlog = true;
                }
            }
            if (versionHasActionlog) {
                const balErrs = await (await configDB.getCollection('actionlog').find({ what: 'balancer.round' })).sort({ time: -1 }).limit(5).toArray();
                const actionReport = { count: 0, lastErr: '', lastTime: ' ' };
                if (balErrs !== null) {
                    balErrs.forEach((r) => {
                        if (r.details.errorOccured) {
                            actionReport.count += 1;
                            if (actionReport.count === 1) {
                                actionReport.lastErr = r.details.errmsg;
                                actionReport.lastTime = r.time;
                            }
                        }
                    });
                }
                balancerRes['Failed balancer rounds in last 5 attempts'] = actionReport.count;
                if (actionReport.count > 0) {
                    balancerRes['Last reported error'] = actionReport.lastErr;
                    balancerRes['Time of Reported error'] = actionReport.lastTime;
                }
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                let migrations = await (await changelogColl
                    .aggregate([
                    {
                        $match: {
                            time: { $gt: yesterday },
                            what: 'moveChunk.from',
                            'details.errmsg': { $exists: false },
                            'details.note': 'success'
                        }
                    },
                    { $group: { _id: { msg: '$details.errmsg' }, count: { $sum: 1 } } },
                    { $project: { _id: { $ifNull: ['$_id.msg', 'Success'] }, count: '$count' } }
                ]))
                    .toArray();
                migrations = migrations.concat(await (await changelogColl
                    .aggregate([
                    {
                        $match: {
                            time: { $gt: yesterday },
                            what: 'moveChunk.from',
                            $or: [
                                { 'details.errmsg': { $exists: true } },
                                { 'details.note': { $ne: 'success' } }
                            ]
                        }
                    },
                    {
                        $group: {
                            _id: { msg: '$details.errmsg', from: '$details.from', to: '$details.to' },
                            count: { $sum: 1 }
                        }
                    },
                    {
                        $project: {
                            _id: { $ifNull: ['$_id.msg', 'aborted'] },
                            from: '$_id.from',
                            to: '$_id.to',
                            count: '$count'
                        }
                    }
                ]))
                    .toArray());
                const migrationsRes = {};
                migrations.forEach((x) => {
                    if (x._id === 'Success') {
                        migrationsRes[x.count] = x._id;
                    }
                    else {
                        migrationsRes[x.count] = `Failed with error '${x._id}', from ${x.from} to ${x.to}`;
                    }
                });
                if (migrations.length === 0) {
                    balancerRes['Migration Results for the last 24 hours'] = 'No recent migrations';
                }
                else {
                    balancerRes['Migration Results for the last 24 hours'] = migrationsRes;
                }
            }
        })()
    ]);
    result.balancer = balancerRes;
    const dbRes = [];
    result.databases = dbRes;
    const databases = await (await configDB.getCollection('databases').find()).sort({ name: 1 }).toArray();
    databases.push({ '_id': 'config', 'primary': 'config', 'partitioned': true });
    databases.sort((a, b) => {
        return a._id.localeCompare(b._id);
    });
    result.databases = await Promise.all(databases.map(async (db) => {
        const escapeRegex = (string) => {
            return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        };
        const colls = await (await configDB.getCollection('collections')
            .find({ _id: new RegExp('^' + escapeRegex(db._id) + '\\.') }))
            .sort({ _id: 1 })
            .toArray();
        const collList = await Promise.all(colls.filter(coll => !coll.dropped).map(async (coll) => {
            const collRes = {};
            collRes.shardKey = coll.key;
            collRes.unique = !!coll.unique;
            if (typeof coll.unique !== 'boolean' && typeof coll.unique !== 'undefined') {
                collRes.unique = [!!coll.unique, { unique: coll.unique }];
            }
            collRes.balancing = !coll.noBalance;
            if (typeof coll.noBalance !== 'boolean' && typeof coll.noBalance !== 'undefined') {
                collRes.balancing = [!coll.noBalance, { noBalance: coll.noBalance }];
            }
            const chunksRes = [];
            const chunksCollMatch = coll.uuid ? { $or: [{ uuid: coll.uuid }, { ns: coll._id }] } : { ns: coll._id };
            const chunks = await (await chunksColl.aggregate([
                { $match: chunksCollMatch },
                { $group: { _id: '$shard', cnt: { $sum: 1 } } },
                { $project: { _id: 0, shard: '$_id', nChunks: '$cnt' } },
                { $sort: { shard: 1 } }
            ])).toArray();
            let totalChunks = 0;
            collRes.chunkMetadata = [];
            chunks.forEach((z) => {
                totalChunks += z.nChunks;
                collRes.chunkMetadata.push({ shard: z.shard, nChunks: z.nChunks });
            });
            if (totalChunks < 20 || verbose) {
                for await (const chunk of (await chunksColl.find(chunksCollMatch)).sort({ min: 1 })) {
                    const c = {
                        min: chunk.min,
                        max: chunk.max,
                        'on shard': chunk.shard,
                        'last modified': chunk.lastmod
                    };
                    Object.defineProperty(c, Symbol.for('nodejs.util.inspect.custom'), {
                        value: function (depth, options) {
                            return util_1.inspect({ ...this }, { ...options, breakLength: Infinity });
                        },
                        writable: true,
                        configurable: true
                    });
                    if (chunk.jumbo)
                        c.jumbo = 'yes';
                    chunksRes.push(c);
                }
            }
            else {
                chunksRes.push('too many chunks to print, use verbose if you want to force print');
            }
            const tagsRes = [];
            for await (const tag of (await configDB.getCollection('tags').find(chunksCollMatch)).sort({ min: 1 })) {
                tagsRes.push({
                    tag: tag.tag,
                    min: tag.min,
                    max: tag.max
                });
            }
            collRes.chunks = chunksRes;
            collRes.tags = tagsRes;
            return [coll._id, collRes];
        }));
        return { database: db, collections: Object.fromEntries(collList) };
    }));
    return result;
}
exports.getPrintableShardStatus = getPrintableShardStatus;
async function getConfigDB(db) {
    const helloResult = await db._maybeCachedHello();
    if (helloResult.msg !== 'isdbgrid') {
        await db._instanceState.printWarning('MongoshWarning: [SHAPI-10003] You are not connected to a mongos. This command may not work as expected.');
    }
    return db.getSiblingDB('config');
}
exports.getConfigDB = getConfigDB;
function dataFormat(bytes) {
    if (bytes === null || bytes === undefined) {
        return '0B';
    }
    if (bytes < 1024) {
        return Math.floor(bytes) + 'B';
    }
    if (bytes < 1024 * 1024) {
        return Math.floor(bytes / 1024) + 'KiB';
    }
    if (bytes < 1024 * 1024 * 1024) {
        return Math.floor((Math.floor(bytes / 1024) / 1024) * 100) / 100 + 'MiB';
    }
    return Math.floor((Math.floor(bytes / (1024 * 1024)) / 1024) * 100) / 100 + 'GiB';
}
exports.dataFormat = dataFormat;
function tsToSeconds(x) {
    if (x.t && x.i) {
        return x.t;
    }
    return x / 4294967296;
}
exports.tsToSeconds = tsToSeconds;
function addHiddenDataProperty(target, key, value) {
    Object.defineProperty(target, key, {
        value,
        enumerable: false,
        writable: true,
        configurable: true
    });
    return target;
}
exports.addHiddenDataProperty = addHiddenDataProperty;
async function iterate(results, cursor, batchSize) {
    if (cursor.isClosed()) {
        return results;
    }
    for (let i = 0; i < batchSize; i++) {
        const doc = await cursor.tryNext();
        if (doc === null) {
            results.cursorHasMore = false;
            break;
        }
        results.documents.push(doc);
    }
    return results;
}
exports.iterate = iterate;
function processFindAndModifyOptions(options) {
    options = { ...options };
    if ('returnDocument' in options) {
        if (options.returnDocument !== 'before' && options.returnDocument !== 'after') {
            throw new errors_1.MongoshInvalidInputError("returnDocument needs to be either 'before' or 'after'", errors_1.CommonErrors.InvalidArgument);
        }
        delete options.returnNewDocument;
        delete options.returnOriginal;
        return options;
    }
    if ('returnOriginal' in options) {
        options.returnDocument = options.returnOriginal ? 'before' : 'after';
        delete options.returnOriginal;
        delete options.returnNewDocument;
        return options;
    }
    if ('returnNewDocument' in options) {
        options.returnDocument = options.returnNewDocument ? 'after' : 'before';
        delete options.returnOriginal;
        delete options.returnNewDocument;
        return options;
    }
    if ('new' in options) {
        options.returnDocument = options.new ? 'after' : 'before';
        delete options.returnOriginal;
        delete options.returnNewDocument;
        return options;
    }
    options.returnDocument = 'before';
    return options;
}
exports.processFindAndModifyOptions = processFindAndModifyOptions;
function processRemoveOptions(options) {
    if (typeof options === 'boolean') {
        return { justOne: options };
    }
    return { justOne: false, ...options };
}
exports.processRemoveOptions = processRemoveOptions;
function processMapReduceOptions(optionsOrOutString) {
    if (typeof optionsOrOutString === 'string') {
        return { out: optionsOrOutString };
    }
    else if (optionsOrOutString.out === undefined) {
        throw new errors_1.MongoshInvalidInputError('Missing \'out\' option', errors_1.CommonErrors.InvalidArgument);
    }
    else {
        return optionsOrOutString;
    }
}
exports.processMapReduceOptions = processMapReduceOptions;
async function setHideIndex(coll, index, hidden) {
    const cmd = typeof index === 'string' ? {
        name: index, hidden
    } : {
        keyPattern: index, hidden
    };
    return await coll._database._runCommand({
        collMod: coll._name,
        index: cmd
    });
}
exports.setHideIndex = setHideIndex;
function assertCLI(platform, features) {
    if (platform !== service_provider_core_1.ReplPlatform.CLI) {
        throw new errors_1.MongoshUnimplementedError(`${features} are not supported for current platform: ${service_provider_core_1.ReplPlatform[platform]}`, errors_1.CommonErrors.NotImplemented);
    }
}
exports.assertCLI = assertCLI;
function processFLEOptions(fleOptions) {
    var _a, _b;
    assertKeysDefined(fleOptions, ['keyVaultNamespace', 'kmsProviders']);
    Object.keys(fleOptions).forEach(k => {
        if (['keyVaultClient', 'keyVaultNamespace', 'kmsProviders', 'schemaMap', 'bypassAutoEncryption'].indexOf(k) === -1) {
            throw new errors_1.MongoshInvalidInputError(`Unrecognized FLE Client Option ${k}`);
        }
    });
    const autoEncryption = {
        keyVaultClient: (_a = fleOptions.keyVaultClient) === null || _a === void 0 ? void 0 : _a._serviceProvider.getRawClient(),
        keyVaultNamespace: fleOptions.keyVaultNamespace
    };
    const localKey = (_b = fleOptions.kmsProviders.local) === null || _b === void 0 ? void 0 : _b.key;
    if (localKey && localKey._bsontype === 'Binary') {
        const rawBuff = localKey.value(true);
        if (Buffer.isBuffer(rawBuff)) {
            autoEncryption.kmsProviders = {
                ...fleOptions.kmsProviders,
                local: {
                    key: rawBuff
                }
            };
        }
        else {
            throw new errors_1.MongoshInvalidInputError('When specifying the key of a local KMS as BSON binary it must be constructed from a base64 encoded string');
        }
    }
    else {
        autoEncryption.kmsProviders = { ...fleOptions.kmsProviders };
    }
    if (fleOptions.schemaMap) {
        autoEncryption.schemaMap = fleOptions.schemaMap;
    }
    if (fleOptions.bypassAutoEncryption !== undefined) {
        autoEncryption.bypassAutoEncryption = fleOptions.bypassAutoEncryption;
    }
    return autoEncryption;
}
exports.processFLEOptions = processFLEOptions;
function maybeMarkAsExplainOutput(value, options) {
    if ('explain' in options) {
        return markAsExplainOutput(value);
    }
    return value;
}
exports.maybeMarkAsExplainOutput = maybeMarkAsExplainOutput;
function markAsExplainOutput(value) {
    if (value !== null && typeof value === 'object') {
        addHiddenDataProperty(value, enums_1.shellApiType, 'ExplainOutput');
    }
    return value;
}
exports.markAsExplainOutput = markAsExplainOutput;
function isValidDatabaseName(name) {
    return !!name && !/[/\\. "\0]/.test(name);
}
exports.isValidDatabaseName = isValidDatabaseName;
function isValidCollectionName(name) {
    return !!name && !/[$\0]/.test(name);
}
exports.isValidCollectionName = isValidCollectionName;
function shouldRunAggregationImmediately(pipeline) {
    return pipeline.some(stage => Object.keys(stage).some(stageName => stageName === '$merge' || stageName === '$out'));
}
exports.shouldRunAggregationImmediately = shouldRunAggregationImmediately;
function isBSONDoubleConvertible(val) {
    return (typeof val === 'number' && Number.isInteger(val)) || (val === null || val === void 0 ? void 0 : val._bsontype) === 'Int32';
}
function adjustRunCommand(cmd, shellBson) {
    if (cmd.replSetResizeOplog) {
        if ('size' in cmd && isBSONDoubleConvertible(cmd.size)) {
            return adjustRunCommand({ ...cmd, size: new shellBson.Double(+cmd.size) }, shellBson);
        }
        if ('minRetentionHours' in cmd && isBSONDoubleConvertible(cmd.minRetentionHours)) {
            return adjustRunCommand({ ...cmd, minRetentionHours: new shellBson.Double(+cmd.minRetentionHours) }, shellBson);
        }
    }
    if (cmd.profile) {
        if ('sampleRate' in cmd && isBSONDoubleConvertible(cmd.sampleRate)) {
            return adjustRunCommand({ ...cmd, sampleRate: new shellBson.Double(+cmd.sampleRate) }, shellBson);
        }
    }
    return cmd;
}
exports.adjustRunCommand = adjustRunCommand;
//# sourceMappingURL=helpers.js.map
import Mongo from './mongo';
import { Namespace, ShellApiWithMongoClass } from './decorators';
import { asPrintable, namespaceInfo } from './enums';
import { FindAndModifyShellOptions, FindAndModifyMethodShellOptions, RemoveShellOptions, MapReduceShellOptions } from './helpers';
import { AnyBulkWriteOperation, BulkWriteOptions, CollStatsOptions, CountOptions, CountDocumentsOptions, ChangeStreamOptions, CreateIndexesOptions, DeleteOptions, DistinctOptions, Document, EstimatedDocumentCountOptions, ExplainVerbosityLike, FindOneAndDeleteOptions, FindOneAndReplaceOptions, FindOneAndUpdateOptions, FindOptions, InsertOneOptions, ReplaceOptions, RunCommandOptions, UpdateOptions } from '@mongosh/service-provider-core';
import { AggregationCursor, BulkWriteResult, CommandResult, Cursor, Database, DeleteResult, Explainable, InsertManyResult, InsertOneResult, UpdateResult } from './index';
import Bulk from './bulk';
import PlanCache from './plan-cache';
import ChangeStreamCursor from './change-stream-cursor';
declare type CollStatsShellOptions = CollStatsOptions & {
    indexDetails?: boolean;
    indexDetailsKey?: Document;
    indexDetailsName?: string;
};
export default class Collection extends ShellApiWithMongoClass {
    _mongo: Mongo;
    _database: Database;
    _name: string;
    constructor(mongo: Mongo, database: Database, name: string);
    [namespaceInfo](): Namespace;
    [asPrintable](): string;
    private _emitCollectionApiCall;
    aggregate(pipeline: Document[], options: Document & {
        explain?: never;
    }): Promise<AggregationCursor>;
    aggregate(pipeline: Document[], options: Document & {
        explain: ExplainVerbosityLike;
    }): Promise<Document>;
    aggregate(...stages: Document[]): Promise<AggregationCursor>;
    bulkWrite(operations: AnyBulkWriteOperation[], options?: BulkWriteOptions): Promise<BulkWriteResult>;
    count(query?: {}, options?: CountOptions): Promise<number>;
    countDocuments(query?: Document, options?: CountDocumentsOptions): Promise<number>;
    deleteMany(filter: Document, options?: DeleteOptions): Promise<DeleteResult | Document>;
    deleteOne(filter: Document, options?: DeleteOptions): Promise<DeleteResult | Document>;
    distinct(field: string): Promise<Document>;
    distinct(field: string, query: Document): Promise<Document>;
    distinct(field: string, query: Document, options: DistinctOptions): Promise<Document>;
    estimatedDocumentCount(options?: EstimatedDocumentCountOptions): Promise<number>;
    find(query?: Document, projection?: Document, options?: FindOptions): Promise<Cursor>;
    findAndModify(options: FindAndModifyMethodShellOptions): Promise<Document>;
    findOne(query?: Document, projection?: Document, options?: FindOptions): Promise<Document | null>;
    renameCollection(newName: string, dropTarget?: boolean): Promise<Document>;
    findOneAndDelete(filter: Document, options?: FindOneAndDeleteOptions): Promise<Document>;
    findOneAndReplace(filter: Document, replacement: Document, options?: FindAndModifyShellOptions<FindOneAndReplaceOptions>): Promise<Document>;
    findOneAndUpdate(filter: Document, update: Document | Document[], options?: FindAndModifyShellOptions<FindOneAndUpdateOptions>): Promise<Document>;
    insert(docs: Document | Document[], options?: BulkWriteOptions): Promise<InsertManyResult>;
    insertMany(docs: Document[], options?: BulkWriteOptions): Promise<InsertManyResult>;
    insertOne(doc: Document, options?: InsertOneOptions): Promise<InsertOneResult>;
    isCapped(): Promise<boolean>;
    remove(query: Document, options?: boolean | RemoveShellOptions): Promise<DeleteResult | Document>;
    save(): never;
    replaceOne(filter: Document, replacement: Document, options?: ReplaceOptions): Promise<UpdateResult>;
    update(filter: Document, update: Document, options?: UpdateOptions & {
        multi?: boolean;
    }): Promise<UpdateResult | Document>;
    updateMany(filter: Document, update: Document, options?: UpdateOptions): Promise<UpdateResult | Document>;
    updateOne(filter: Document, update: Document, options?: UpdateOptions): Promise<UpdateResult | Document>;
    convertToCapped(size: number): Promise<Document>;
    createIndexes(keyPatterns: Document[], options?: CreateIndexesOptions): Promise<string[]>;
    createIndex(keys: Document, options?: CreateIndexesOptions): Promise<string>;
    ensureIndex(keys: Document, options?: CreateIndexesOptions): Promise<Document>;
    getIndexes(): Promise<Document[]>;
    getIndexSpecs(): Promise<Document[]>;
    getIndices(): Promise<Document[]>;
    getIndexKeys(): Promise<Document[]>;
    dropIndexes(indexes?: string | string[] | Document | Document[]): Promise<Document>;
    dropIndex(index: string | Document): Promise<Document>;
    totalIndexSize(...args: any[]): Promise<number>;
    reIndex(): Promise<Document>;
    getDB(): Database;
    getMongo(): Mongo;
    dataSize(): Promise<number>;
    storageSize(): Promise<number>;
    totalSize(): Promise<number>;
    drop(): Promise<boolean>;
    exists(): Promise<Document>;
    getFullName(): string;
    getName(): string;
    runCommand(commandName: string | Document, options?: RunCommandOptions): Promise<Document>;
    explain(verbosity?: ExplainVerbosityLike): Explainable;
    stats(originalOptions?: CollStatsShellOptions | number): Promise<Document>;
    latencyStats(options?: Document): Promise<Document[]>;
    initializeOrderedBulkOp(): Promise<Bulk>;
    initializeUnorderedBulkOp(): Promise<Bulk>;
    getPlanCache(): PlanCache;
    mapReduce(map: Function | string, reduce: Function | string, optionsOrOutString: MapReduceShellOptions): Promise<Document>;
    validate(options?: boolean | Document): Promise<Document>;
    getShardVersion(): Promise<Document>;
    getShardDistribution(): Promise<CommandResult>;
    watch(pipeline?: Document[] | ChangeStreamOptions, options?: ChangeStreamOptions): Promise<ChangeStreamCursor>;
    hideIndex(index: string | Document): Promise<Document>;
    unhideIndex(index: string | Document): Promise<Document>;
}
export {};

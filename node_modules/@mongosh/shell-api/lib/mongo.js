"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@mongosh/errors");
const decorators_1 = require("./decorators");
const service_provider_core_1 = require("@mongosh/service-provider-core");
const database_1 = __importDefault(require("./database"));
const result_1 = require("./result");
const history_1 = require("@mongosh/history");
const enums_1 = require("./enums");
const session_1 = __importDefault(require("./session"));
const helpers_1 = require("./helpers");
const change_stream_cursor_1 = __importDefault(require("./change-stream-cursor"));
const error_codes_1 = require("./error-codes");
const field_level_encryption_1 = require("./field-level-encryption");
const error_codes_2 = require("./error-codes");
let Mongo = class Mongo extends decorators_1.ShellApiClass {
    constructor(instanceState, uri, fleOptions, otherOptions, sp) {
        var _a, _b, _c;
        super();
        this.__serviceProvider = null;
        this._readPreferenceWasExplicitlyRequested = false;
        this._explicitEncryptionOnly = false;
        this._cachedDatabaseNames = [];
        this._instanceState = instanceState;
        this._databases = {};
        if (sp) {
            this.__serviceProvider = sp;
        }
        if (typeof uri === 'string') {
            this._uri = service_provider_core_1.generateUri({ connectionSpecifier: uri });
        }
        else {
            this._uri = (_b = (_a = sp === null || sp === void 0 ? void 0 : sp.getURI) === null || _a === void 0 ? void 0 : _a.call(sp)) !== null && _b !== void 0 ? _b : service_provider_core_1.generateUri({ connectionSpecifier: 'mongodb://localhost/' });
        }
        this._readPreferenceWasExplicitlyRequested = /\breadPreference=/.test(this._uri);
        if (fleOptions) {
            if (fleOptions.explicitEncryptionOnly !== undefined) {
                if (fleOptions.schemaMap !== undefined) {
                    throw new errors_1.MongoshInvalidInputError('explicitEncryptionOnly and schemaMap are mutually exclusive', errors_1.CommonErrors.InvalidArgument);
                }
                fleOptions = { ...fleOptions };
                this._explicitEncryptionOnly = !!fleOptions.explicitEncryptionOnly;
                delete fleOptions.explicitEncryptionOnly;
            }
            this._fleOptions = helpers_1.processFLEOptions(fleOptions);
        }
        else {
            const spFleOptions = (_c = sp === null || sp === void 0 ? void 0 : sp.getFleOptions) === null || _c === void 0 ? void 0 : _c.call(sp);
            if (spFleOptions) {
                this._fleOptions = spFleOptions;
            }
        }
        if (otherOptions === null || otherOptions === void 0 ? void 0 : otherOptions.api) {
            if (typeof otherOptions.api === 'string') {
                this._apiOptions = { version: otherOptions.api };
            }
            else {
                this._apiOptions = otherOptions.api;
            }
        }
    }
    get _serviceProvider() {
        if (this.__serviceProvider === null) {
            throw new errors_1.MongoshInternalError('No ServiceProvider available for this mongo', error_codes_2.ShellApiErrors.NotConnected);
        }
        return this.__serviceProvider;
    }
    set _serviceProvider(sp) {
        this.__serviceProvider = sp;
    }
    async _displayBatchSize() {
        var _a;
        return (_a = this._instanceState.displayBatchSizeFromDBQuery) !== null && _a !== void 0 ? _a : await this._instanceState.shellApi.config.get('displayBatchSize');
    }
    [enums_1.asPrintable]() {
        return history_1.redactURICredentials(this._uri);
    }
    _emitMongoApiCall(methodName, methodArguments = {}) {
        this._instanceState.emitApiCallWithArgs({
            method: methodName,
            class: 'Mongo',
            uri: this._uri,
            arguments: methodArguments
        });
    }
    async connect(user, pwd) {
        var _a, _b, _c, _d, _e, _f;
        const mongoClientOptions = user || pwd ? {
            auth: { username: user, password: pwd }
        } : {};
        if (this._fleOptions && !this._explicitEncryptionOnly) {
            const extraOptions = {
                ...((_a = this._fleOptions.extraOptions) !== null && _a !== void 0 ? _a : {}),
                ...((_d = await ((_c = (_b = this._instanceState.evaluationListener) === null || _b === void 0 ? void 0 : _b.startMongocryptd) === null || _c === void 0 ? void 0 : _c.call(_b))) !== null && _d !== void 0 ? _d : {})
            };
            mongoClientOptions.autoEncryption = { ...this._fleOptions, extraOptions };
        }
        if (this._apiOptions) {
            mongoClientOptions.serverApi = this._apiOptions;
        }
        const parentProvider = this._instanceState.initialServiceProvider;
        try {
            this.__serviceProvider = await parentProvider.getNewConnection(this._uri, mongoClientOptions);
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.name) === 'MongoServerSelectionError' &&
                ((_f = (_e = parentProvider.getRawClient()) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f.tls) &&
                !this._uri.match(/\b(ssl|tls)=/)) {
                e.message += ' (is ?tls=true missing from the connection string?)';
            }
            throw e;
        }
    }
    _getDb(name) {
        helpers_1.assertArgsDefinedType([name], ['string']);
        if (!helpers_1.isValidDatabaseName(name)) {
            throw new errors_1.MongoshInvalidInputError(`Invalid database name: ${name}`, errors_1.CommonErrors.InvalidArgument);
        }
        if (!(name in this._databases)) {
            this._databases[name] = new database_1.default(this, name);
        }
        return this._databases[name];
    }
    getDB(db) {
        helpers_1.assertArgsDefinedType([db], ['string'], 'Mongo.getDB');
        this._instanceState.messageBus.emit('mongosh:getDB', { db });
        return this._getDb(db);
    }
    getCollection(name) {
        var _a, _b;
        helpers_1.assertArgsDefinedType([name], ['string']);
        const { db, coll } = (_b = (_a = name.match(/^(?<db>[^.]+)\.(?<coll>.+)$/)) === null || _a === void 0 ? void 0 : _a.groups) !== null && _b !== void 0 ? _b : {};
        if (!db || !coll) {
            throw new errors_1.MongoshInvalidInputError('Collection must be of the format <db>.<collection>', errors_1.CommonErrors.InvalidArgument);
        }
        return this._getDb(db).getCollection(coll);
    }
    use(db) {
        var _a;
        helpers_1.assertArgsDefinedType([db], ['string'], 'Mongo.use');
        this._instanceState.messageBus.emit('mongosh:use', { db });
        let previousDbName;
        let previousDbMongo;
        try {
            const previousDb = this._instanceState.context.db;
            previousDbName = (_a = previousDb === null || previousDb === void 0 ? void 0 : previousDb.getName) === null || _a === void 0 ? void 0 : _a.call(previousDb);
            previousDbMongo = previousDb === null || previousDb === void 0 ? void 0 : previousDb._mongo;
        }
        catch (e) {
            if (e.code !== error_codes_2.ShellApiErrors.NotConnected) {
                throw e;
            }
        }
        this._instanceState.context.db = this._getDb(db);
        if (db === previousDbName && previousDbMongo === this) {
            return `already on db ${db}`;
        }
        return `switched to db ${db}`;
    }
    async _listDatabases(opts = {}) {
        const result = await this._serviceProvider.listDatabases('admin', {
            ...this._getExplicitlyRequestedReadPref(),
            ...opts
        });
        if (!('databases' in result)) {
            const err = new errors_1.MongoshRuntimeError('Got invalid result from "listDatabases"', errors_1.CommonErrors.CommandFailed);
            this._instanceState.messageBus.emit('mongosh:error', err, 'shell-api');
            throw err;
        }
        this._cachedDatabaseNames = result.databases.map((db) => db.name);
        return result;
    }
    async _getDatabaseNamesForCompletion() {
        return await Promise.race([
            (async () => {
                return (await this._listDatabases({ readPreference: 'primaryPreferred' })).databases.map(db => db.name);
            })(),
            (async () => {
                await new Promise(resolve => setTimeout(resolve, 200).unref());
                return this._cachedDatabaseNames;
            })()
        ]);
    }
    async getDBs(options = {}) {
        this._emitMongoApiCall('getDBs', { options });
        return await this._listDatabases(options);
    }
    async getDBNames(options = {}) {
        this._emitMongoApiCall('getDBNames', { options });
        return (await this._listDatabases(options)).databases.map(db => db.name);
    }
    async show(cmd, arg) {
        this._instanceState.messageBus.emit('mongosh:show', { method: `show ${cmd}` });
        switch (cmd) {
            case 'databases':
            case 'dbs':
                const result = (await this._listDatabases({ readPreference: 'primaryPreferred', promoteLongs: true })).databases;
                return new result_1.CommandResult('ShowDatabasesResult', result);
            case 'collections':
            case 'tables':
                const collectionNames = await this._instanceState.currentDb._getCollectionNamesWithTypes({ readPreference: 'primaryPreferred', promoteLongs: true });
                return new result_1.CommandResult('ShowCollectionsResult', collectionNames);
            case 'profile':
                const sysprof = this._instanceState.currentDb.getCollection('system.profile');
                const profiles = { count: await sysprof.countDocuments({}) };
                if (profiles.count !== 0) {
                    profiles.result = await (await sysprof.find({ millis: { $gt: 0 } }))
                        .sort({ $natural: -1 })
                        .limit(5)
                        .toArray();
                }
                return new result_1.CommandResult('ShowProfileResult', profiles);
            case 'users':
                const users = await this._instanceState.currentDb.getUsers();
                return new result_1.CommandResult('ShowResult', users.users);
            case 'roles':
                const roles = await this._instanceState.currentDb.getRoles({ showBuiltinRoles: true });
                return new result_1.CommandResult('ShowResult', roles.roles);
            case 'log':
                const log = await this._instanceState.currentDb.adminCommand({ getLog: arg || 'global' });
                return new result_1.CommandResult('ShowResult', log.log);
            case 'logs':
                const logs = await this._instanceState.currentDb.adminCommand({ getLog: '*' });
                return new result_1.CommandResult('ShowResult', logs.names);
            default:
                const err = new errors_1.MongoshInvalidInputError(`'${cmd}' is not a valid argument for "show".`, errors_1.CommonErrors.InvalidArgument);
                this._instanceState.messageBus.emit('mongosh:error', err, 'shell-api');
                throw err;
        }
    }
    async close(force) {
        const index = this._instanceState.mongos.indexOf(this);
        if (index === -1) {
            process.emitWarning(new errors_1.MongoshInternalError(`Closing untracked Mongo instance ${this[enums_1.asPrintable]()}`));
        }
        else {
            this._instanceState.mongos.splice(index, 1);
        }
        await this._serviceProvider.close(force);
    }
    async _suspend() {
        return await this._serviceProvider.suspend();
    }
    getReadPrefMode() {
        return this._serviceProvider.getReadPreference().mode;
    }
    getReadPrefTagSet() {
        return this._serviceProvider.getReadPreference().tags;
    }
    getReadPref() {
        return this._serviceProvider.getReadPreference();
    }
    _getExplicitlyRequestedReadPref() {
        return this._readPreferenceWasExplicitlyRequested ?
            { readPreference: this.getReadPref() } :
            undefined;
    }
    getReadConcern() {
        try {
            const rc = this._serviceProvider.getReadConcern();
            return rc ? rc.level : undefined;
        }
        catch (_a) {
            throw new errors_1.MongoshInternalError('Error retrieving ReadConcern.');
        }
    }
    getWriteConcern() {
        try {
            return this._serviceProvider.getWriteConcern();
        }
        catch (_a) {
            throw new errors_1.MongoshInternalError('Error retrieving WriteConcern.');
        }
    }
    async setReadPref(mode, tagSet, hedgeOptions) {
        await this._serviceProvider.resetConnectionOptions({
            readPreference: this._serviceProvider.readPreferenceFromOptions({
                readPreference: mode,
                readPreferenceTags: tagSet,
                hedge: hedgeOptions
            })
        });
        this._readPreferenceWasExplicitlyRequested = true;
    }
    async setReadConcern(level) {
        await this._serviceProvider.resetConnectionOptions({ readConcern: { level: level } });
    }
    async setWriteConcern(concernOrWValue, wtimeoutMSValue, jValue) {
        const options = {};
        let concern;
        if (typeof concernOrWValue === 'object') {
            if (wtimeoutMSValue !== undefined || jValue !== undefined) {
                throw new errors_1.MongoshInvalidInputError('If concern is given as an object no other arguments must be specified', errors_1.CommonErrors.InvalidArgument);
            }
            concern = concernOrWValue;
        }
        else {
            concern = {};
            if (typeof concernOrWValue !== 'string' && typeof concernOrWValue !== 'number') {
                throw new errors_1.MongoshInvalidInputError(`w value must be a number or string, got: ${typeof concernOrWValue}`, errors_1.CommonErrors.InvalidArgument);
            }
            else if (typeof concernOrWValue === 'number' && concernOrWValue < 0) {
                throw new errors_1.MongoshInvalidInputError(`w value must be equal to or greather than 0, got: ${concernOrWValue}`, errors_1.CommonErrors.InvalidArgument);
            }
            concern.w = concernOrWValue;
            if (wtimeoutMSValue !== undefined) {
                if (typeof wtimeoutMSValue !== 'number') {
                    throw new errors_1.MongoshInvalidInputError(`wtimeoutMS value must be a number, got: ${typeof wtimeoutMSValue}`, errors_1.CommonErrors.InvalidArgument);
                }
                else if (wtimeoutMSValue < 0) {
                    throw new errors_1.MongoshInvalidInputError(`wtimeoutMS must be equal to or greather than 0, got: ${wtimeoutMSValue}`, errors_1.CommonErrors.InvalidArgument);
                }
                concern.wtimeout = wtimeoutMSValue;
            }
            if (jValue !== undefined) {
                if (typeof jValue !== 'boolean') {
                    throw new errors_1.MongoshInvalidInputError(`j value must be a boolean, got: ${typeof jValue}`, errors_1.CommonErrors.InvalidArgument);
                }
                concern.j = jValue;
            }
        }
        if (concern.w !== undefined) {
            options.w = concern.w;
        }
        if (concern.wtimeout !== undefined) {
            options.wtimeoutMS = concern.wtimeout;
        }
        if (concern.j !== undefined) {
            options.journal = concern.j;
        }
        if (concern.fsync !== undefined) {
            options.journal = !!concern.fsync;
        }
        await this._serviceProvider.resetConnectionOptions(options);
    }
    startSession(options = {}) {
        const driverOptions = {};
        if (options === undefined) {
            return new session_1.default(this, driverOptions, this._serviceProvider.startSession(driverOptions));
        }
        const defaultTransactionOptions = {};
        Object.assign(defaultTransactionOptions, options.readConcern && { readConcern: options.readConcern }, options.writeConcern && { writeConcern: options.writeConcern }, options.readPreference && { readPreference: options.readPreference });
        Object.assign(driverOptions, Object.keys(defaultTransactionOptions).length > 0 && { defaultTransactionOptions: defaultTransactionOptions }, options.causalConsistency !== undefined && { causalConsistency: options.causalConsistency });
        return new session_1.default(this, driverOptions, this._serviceProvider.startSession(driverOptions));
    }
    setCausalConsistency() {
        throw new errors_1.MongoshUnimplementedError('It is not possible to set causal consistency for an entire connection due to the driver, use startSession({causalConsistency: <>}) instead.', errors_1.CommonErrors.NotImplemented, error_codes_1.blockedByDriverMetadata('Mongo.setCausalConsistency'));
    }
    isCausalConsistency() {
        throw new errors_1.MongoshUnimplementedError('Causal consistency for drivers is set via Mongo.startSession and can be checked via session.getOptions. The default value is true', errors_1.CommonErrors.NotImplemented, error_codes_1.blockedByDriverMetadata('Mongo.isCausalConsistency'));
    }
    setSlaveOk() {
        throw new errors_1.MongoshDeprecatedError('Setting slaveOk is deprecated, use setReadPref instead.');
    }
    async setSecondaryOk() {
        await this._instanceState.printDeprecationWarning('.setSecondaryOk() is deprecated. Use .setReadPref("primaryPreferred") instead');
        const currentReadPref = this.getReadPrefMode();
        if (currentReadPref === 'primary') {
            await this._instanceState.shellApi.print('Setting read preference from "primary" to "primaryPreferred"');
            await this.setReadPref('primaryPreferred');
        }
        else {
            await this._instanceState.shellApi.print(`Leaving read preference unchanged (is already "${currentReadPref}")`);
        }
    }
    async watch(pipeline = [], options = {}) {
        if (!Array.isArray(pipeline)) {
            options = pipeline;
            pipeline = [];
        }
        this._emitMongoApiCall('watch', { pipeline, options });
        const cursor = new change_stream_cursor_1.default(this._serviceProvider.watch(pipeline, options), history_1.redactURICredentials(this._uri), this);
        if (!options.resumeAfter && !options.startAfter && !options.startAtOperationTime) {
            await cursor.tryNext();
        }
        this._instanceState.currentCursor = cursor;
        return cursor;
    }
    getClientEncryption() {
        if (!this._fleOptions) {
            throw new errors_1.MongoshInvalidInputError('Cannot call getClientEncryption() without field-level encryption options', error_codes_2.ShellApiErrors.NotUsingFLE);
        }
        if (!this._clientEncryption) {
            this._clientEncryption = new field_level_encryption_1.ClientEncryption(this);
        }
        return this._clientEncryption;
    }
    getKeyVault() {
        this._keyVault = new field_level_encryption_1.KeyVault(this.getClientEncryption());
        return this._keyVault;
    }
};
__decorate([
    decorators_1.returnType('Database')
], Mongo.prototype, "getDB", null);
__decorate([
    decorators_1.returnType('Collection')
], Mongo.prototype, "getCollection", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Mongo.prototype, "getDBs", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Mongo.prototype, "getDBNames", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], Mongo.prototype, "show", null);
__decorate([
    decorators_1.returnsPromise
], Mongo.prototype, "setReadPref", null);
__decorate([
    decorators_1.returnsPromise
], Mongo.prototype, "setReadConcern", null);
__decorate([
    decorators_1.returnsPromise
], Mongo.prototype, "setWriteConcern", null);
__decorate([
    decorators_1.topologies([enums_1.Topologies.ReplSet])
], Mongo.prototype, "startSession", null);
__decorate([
    decorators_1.deprecated
], Mongo.prototype, "setSlaveOk", null);
__decorate([
    decorators_1.deprecated,
    decorators_1.returnsPromise
], Mongo.prototype, "setSecondaryOk", null);
__decorate([
    decorators_1.serverVersions(['3.1.0', enums_1.ServerVersions.latest]),
    decorators_1.topologies([enums_1.Topologies.ReplSet, enums_1.Topologies.Sharded]),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], Mongo.prototype, "watch", null);
__decorate([
    decorators_1.platforms([service_provider_core_1.ReplPlatform.CLI]),
    decorators_1.serverVersions(['4.2.0', enums_1.ServerVersions.latest]),
    decorators_1.returnType('ClientEncryption')
], Mongo.prototype, "getClientEncryption", null);
__decorate([
    decorators_1.platforms([service_provider_core_1.ReplPlatform.CLI]),
    decorators_1.serverVersions(['4.2.0', enums_1.ServerVersions.latest]),
    decorators_1.returnType('KeyVault')
], Mongo.prototype, "getKeyVault", null);
Mongo = __decorate([
    decorators_1.shellApiClassDefault,
    decorators_1.classPlatforms([service_provider_core_1.ReplPlatform.CLI])
], Mongo);
exports.default = Mongo;
//# sourceMappingURL=mongo.js.map
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyVault = exports.ClientEncryption = void 0;
const decorators_1 = require("./decorators");
const service_provider_core_1 = require("@mongosh/service-provider-core");
const helpers_1 = require("./helpers");
const enums_1 = require("./enums");
const history_1 = require("@mongosh/history");
const errors_1 = require("@mongosh/errors");
let ClientEncryption = class ClientEncryption extends decorators_1.ShellApiWithMongoClass {
    constructor(mongo) {
        super();
        this._mongo = mongo;
        const fle = mongo._serviceProvider.fle;
        if (!fle) {
            throw new errors_1.MongoshRuntimeError('FLE API is not available');
        }
        this._libmongocrypt = new fle.ClientEncryption(mongo._serviceProvider.getRawClient(), {
            ...this._mongo._fleOptions
        });
    }
    [enums_1.asPrintable]() {
        return `ClientEncryption class for ${history_1.redactURICredentials(this._mongo._uri)}`;
    }
    async encrypt(encryptionId, value, encryptionAlgorithm) {
        helpers_1.assertArgsDefinedType([encryptionId, value, encryptionAlgorithm], [true, true, true], 'ClientEncryption.encrypt');
        return await this._libmongocrypt.encrypt(value, {
            keyId: encryptionId,
            algorithm: encryptionAlgorithm
        });
    }
    async decrypt(encryptedValue) {
        helpers_1.assertArgsDefinedType([encryptedValue], [true], 'ClientEncryption.decrypt');
        return await this._libmongocrypt.decrypt(encryptedValue);
    }
};
__decorate([
    decorators_1.returnsPromise
], ClientEncryption.prototype, "encrypt", null);
__decorate([
    decorators_1.returnsPromise
], ClientEncryption.prototype, "decrypt", null);
ClientEncryption = __decorate([
    decorators_1.shellApiClassDefault,
    decorators_1.classPlatforms([service_provider_core_1.ReplPlatform.CLI])
], ClientEncryption);
exports.ClientEncryption = ClientEncryption;
let KeyVault = class KeyVault extends decorators_1.ShellApiWithMongoClass {
    constructor(clientEncryption) {
        super();
        this._mongo = clientEncryption._mongo;
        this._clientEncryption = clientEncryption;
        if (!this._mongo._fleOptions || !this._mongo._fleOptions.keyVaultNamespace) {
            throw new errors_1.MongoshInvalidInputError('FLE options must be passed to the Mongo object');
        }
        const [db, coll] = this._mongo._fleOptions.keyVaultNamespace.split('.');
        this._keyColl = this._mongo.getDB(db).getCollection(coll);
    }
    [enums_1.asPrintable]() {
        return `KeyVault class for ${history_1.redactURICredentials(this._mongo._uri)}`;
    }
    async createKey(kms, masterKeyOrAltNames, keyAltNames) {
        helpers_1.assertArgsDefinedType([kms], [true], 'KeyVault.createKey');
        if (typeof masterKeyOrAltNames === 'string') {
            if (kms === 'local' && masterKeyOrAltNames === '') {
                masterKeyOrAltNames = undefined;
            }
            else {
                throw new errors_1.MongoshInvalidInputError('KeyVault.createKey does not support providing masterKey as string anymore. For AWS please use createKey("aws", { region: ..., key: ... })', errors_1.CommonErrors.Deprecated);
            }
        }
        else if (Array.isArray(masterKeyOrAltNames)) {
            if (kms !== 'local') {
                throw new errors_1.MongoshInvalidInputError('KeyVault.createKey requires masterKey to be given as second argument if KMS is not local', errors_1.CommonErrors.InvalidArgument);
            }
            else {
                if (keyAltNames) {
                    throw new errors_1.MongoshInvalidInputError('KeyVault.createKey was supplied with an array for the masterKey and keyAltNames - either specify keyAltNames as second argument or set undefined for masterKey', errors_1.CommonErrors.InvalidArgument);
                }
                keyAltNames = masterKeyOrAltNames;
                masterKeyOrAltNames = undefined;
            }
        }
        let options;
        if (masterKeyOrAltNames) {
            options = {
                masterKey: masterKeyOrAltNames
            };
        }
        if (keyAltNames) {
            options = {
                ...(options !== null && options !== void 0 ? options : {}),
                keyAltNames
            };
        }
        return await this._clientEncryption._libmongocrypt.createDataKey(kms, options);
    }
    async getKey(keyId) {
        helpers_1.assertArgsDefinedType([keyId], [true], 'KeyVault.getKey');
        return this._keyColl.find({ '_id': keyId });
    }
    async getKeyByAltName(keyAltName) {
        helpers_1.assertArgsDefinedType([keyAltName], ['string'], 'KeyVault.getKeyByAltName');
        return this._keyColl.find({ 'keyAltNames': keyAltName });
    }
    async getKeys() {
        return this._keyColl.find({});
    }
    async deleteKey(keyId) {
        helpers_1.assertArgsDefinedType([keyId], [true], 'KeyVault.deleteKey');
        return this._keyColl.deleteOne({ '_id': keyId });
    }
    async addKeyAlternateName(keyId, keyAltName) {
        helpers_1.assertArgsDefinedType([keyId, keyAltName], [true, 'string'], 'KeyVault.addKeyAlternateName');
        return this._keyColl.findAndModify({
            query: { '_id': keyId },
            update: { $push: { 'keyAltNames': keyAltName }, $currentDate: { 'updateDate': true } },
        });
    }
    async removeKeyAlternateName(keyId, keyAltName) {
        helpers_1.assertArgsDefinedType([keyId, keyAltName], [true, 'string'], 'KeyVault.removeKeyAlternateName');
        const ret = await this._keyColl.findAndModify({
            query: { '_id': keyId },
            update: { $pull: { 'keyAltNames': keyAltName }, $currentDate: { 'updateDate': true } }
        });
        if (ret !== null && ret.keyAltNames !== undefined && ret.keyAltNames.length === 1 && ret.keyAltNames[0] === keyAltName) {
            return this._keyColl.findAndModify({
                query: { '_id': keyId, 'keyAltNames': undefined },
                update: { $unset: { 'keyAltNames': '' }, $currentDate: { 'updateDate': true } }
            });
        }
        return ret;
    }
};
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], KeyVault.prototype, "createKey", null);
__decorate([
    decorators_1.returnType('Cursor'),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKey", null);
__decorate([
    decorators_1.returnType('Cursor'),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKeyByAltName", null);
__decorate([
    decorators_1.returnType('Cursor'),
    decorators_1.apiVersions([1]),
    decorators_1.returnsPromise
], KeyVault.prototype, "getKeys", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], KeyVault.prototype, "deleteKey", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], KeyVault.prototype, "addKeyAlternateName", null);
__decorate([
    decorators_1.returnsPromise,
    decorators_1.apiVersions([1])
], KeyVault.prototype, "removeKeyAlternateName", null);
KeyVault = __decorate([
    decorators_1.shellApiClassDefault,
    decorators_1.classPlatforms([service_provider_core_1.ReplPlatform.CLI])
], KeyVault);
exports.KeyVault = KeyVault;
//# sourceMappingURL=field-level-encryption.js.map
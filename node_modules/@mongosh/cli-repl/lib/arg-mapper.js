"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTlsCertificateSelector = void 0;
const errors_1 = require("@mongosh/errors");
const lodash_set_1 = __importDefault(require("lodash.set"));
const MAPPINGS = {
    apiDeprecationErrors: 'serverApi.deprecationErrors',
    apiStrict: 'serverApi.strict',
    apiVersion: 'serverApi.version',
    awsAccessKeyId: 'autoEncryption.kmsProviders.aws.accessKeyId',
    awsSecretAccessKey: 'autoEncryption.kmsProviders.aws.secretAccessKey',
    awsSessionToken: 'autoEncryption.kmsProviders.aws.sessionToken',
    awsIamSessionToken: 'authMechanismProperties.AWS_SESSION_TOKEN',
    gssapiServiceName: 'authMechanismProperties.SERVICE_NAME',
    sspiRealmOverride: 'authMechanismProperties.SERVICE_REALM',
    sspiHostnameCanonicalization: { opt: 'authMechanismProperties.gssapiCanonicalizeHostName', fun: mapSspiHostnameCanonicalization },
    authenticationDatabase: 'authSource',
    authenticationMechanism: 'authMechanism',
    keyVaultNamespace: 'autoEncryption.keyVaultNamespace',
    password: 'auth.password',
    quiet: { opt: 'loggerLevel', val: 'error' },
    retryWrites: 'retryWrites',
    tls: 'tls',
    tlsAllowInvalidCertificates: 'tlsAllowInvalidCertificates',
    tlsAllowInvalidHostnames: 'tlsAllowInvalidHostnames',
    tlsCAFile: 'tlsCAFile',
    tlsCRLFile: 'sslCRL',
    tlsCertificateKeyFile: 'tlsCertificateKeyFile',
    tlsCertificateKeyFilePassword: 'tlsCertificateKeyFilePassword',
    username: 'auth.username',
    verbose: { opt: 'loggerLevel', val: 'debug' }
};
function isExistingMappingKey(key, options) {
    return MAPPINGS.hasOwnProperty(key) && options.hasOwnProperty(key);
}
function mapCliToDriver(options) {
    const nodeOptions = {};
    for (const cliOption of Object.keys(MAPPINGS)) {
        if (isExistingMappingKey(cliOption, options)) {
            const mapping = MAPPINGS[cliOption];
            if (typeof mapping === 'object') {
                const cliValue = options[cliOption];
                if (cliValue) {
                    let newValue;
                    if ('val' in mapping) {
                        newValue = mapping.val;
                    }
                    else {
                        newValue = mapping.fun(cliValue);
                        if (newValue === undefined) {
                            continue;
                        }
                    }
                    lodash_set_1.default(nodeOptions, mapping.opt, newValue);
                }
            }
            else {
                lodash_set_1.default(nodeOptions, mapping, options[cliOption]);
            }
        }
    }
    const { version } = require('../package.json');
    return {
        ...nodeOptions,
        ...getTlsCertificateSelector(options.tlsCertificateSelector),
        driverInfo: { name: 'mongosh', version }
    };
}
function getTlsCertificateSelector(selector) {
    var _a, _b, _c;
    if (!selector) {
        return;
    }
    const exportCertificateAndPrivateKey = getCertificateExporter();
    if (!exportCertificateAndPrivateKey) {
        throw new errors_1.MongoshUnimplementedError('--tlsCertificateSelector is not supported on this platform');
    }
    const match = selector.match(/^(?<key>\w+)=(?<value>.+)/);
    if (!match || !['subject', 'thumbprint'].includes((_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.key) !== null && _b !== void 0 ? _b : '')) {
        throw new errors_1.MongoshInvalidInputError('--tlsCertificateSelector needs to include subject or thumbprint');
    }
    const { key, value } = (_c = match.groups) !== null && _c !== void 0 ? _c : {};
    const search = key === 'subject' ? { subject: value } : { thumbprint: Buffer.from(value, 'hex') };
    try {
        const { passphrase, pfx } = exportCertificateAndPrivateKey(search);
        return { passphrase, pfx };
    }
    catch (err) {
        throw new errors_1.MongoshInvalidInputError(`Could not resolve certificate specification '${selector}': ${err.message}`);
    }
}
exports.getTlsCertificateSelector = getTlsCertificateSelector;
function getCertificateExporter() {
    if (process.env.TEST_OS_EXPORT_CERTIFICATE_AND_KEY_PATH) {
        return require(process.env.TEST_OS_EXPORT_CERTIFICATE_AND_KEY_PATH);
    }
    try {
        switch (process.platform) {
            case 'win32':
                return require('win-export-certificate-and-key');
            case 'darwin':
                return require('macos-export-certificate-and-key');
            default:
                return undefined;
        }
    }
    catch (_a) { }
    return undefined;
}
function mapSspiHostnameCanonicalization(value) {
    if (!value || value === 'none') {
        return undefined;
    }
    if (value === 'forward') {
        return 'true';
    }
    throw new errors_1.MongoshInvalidInputError(`--sspiHostnameCanonicalization value ${value} is not supported`, errors_1.CommonErrors.InvalidArgument);
}
exports.default = mapCliToDriver;
//# sourceMappingURL=arg-mapper.js.map
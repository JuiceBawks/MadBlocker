"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongocryptdManager = exports.getMongocryptdPaths = void 0;
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const net_1 = require("net");
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const stream_1 = require("stream");
const errors_1 = require("@mongosh/errors");
const service_provider_server_1 = require("@mongosh/service-provider-server");
const log_entry_1 = require("./log-entry");
async function getMongocryptdPaths() {
    const bindir = path_1.default.dirname(process.execPath);
    const result = [];
    for await (const mongocryptdCandidate of [
        path_1.default.resolve(bindir, '..', 'libexec', 'mongocryptd-mongosh'),
        path_1.default.resolve(bindir, 'mongocryptd-mongosh'),
        path_1.default.resolve(bindir, 'mongocryptd-mongosh.exe')
    ]) {
        try {
            await fs_1.promises.access(mongocryptdCandidate, fs_1.constants.X_OK);
            result.push([mongocryptdCandidate]);
        }
        catch (_a) { }
    }
    return [...result, ['mongocryptd']];
}
exports.getMongocryptdPaths = getMongocryptdPaths;
class MongocryptdManager {
    constructor(spawnPaths, shellHomeDirectory, bus) {
        this.idleShutdownTimeoutSecs = 60;
        this.close = () => {
            process.removeListener('exit', this.close);
            if (this.state) {
                this.state.proc.kill();
                clearInterval(this.state.interval);
                this.state = null;
            }
            return this;
        };
        this.spawnPaths = spawnPaths;
        this.path = shellHomeDirectory.localPath(`mongocryptd-${process.pid}-${(Math.random() * 100000) | 0}`);
        this.bus = bus;
        this.state = null;
    }
    async start() {
        if (!this.state) {
            [this.state] = await Promise.all([
                this._spawn(),
                this._cleanupOldMongocryptdDirectories()
            ]);
        }
        return {
            mongocryptdURI: this.state.uri,
            mongocryptdBypassSpawn: true
        };
    }
    async *createLogEntryIterator(stdout, pid) {
        for await (const line of readline_1.default.createInterface({ input: stdout })) {
            if (!line.trim()) {
                continue;
            }
            try {
                const logEntry = log_entry_1.parseAnyLogEntry(line);
                this.bus.emit('mongosh:mongocryptd-log', { pid, logEntry });
                yield logEntry;
            }
            catch (error) {
                this.bus.emit('mongosh:mongocryptd-error', { pid, cause: 'parse', error });
                break;
            }
        }
    }
    _spawnMongocryptdProcess(spawnPath) {
        const [executable, ...args] = [
            ...spawnPath,
            '--idleShutdownTimeoutSecs', String(this.idleShutdownTimeoutSecs),
            '--pidfilepath', path_1.default.join(this.path, 'mongocryptd.pid'),
            '--port', '0',
            ...(process.platform !== 'win32' ? ['--unixSocketPrefix', this.path] : [])
        ];
        const proc = child_process_1.spawn(executable, args, {
            stdio: ['inherit', 'pipe', 'pipe']
        });
        proc.on('exit', (code, signal) => {
            const logEntry = { exit: { code, signal } };
            this.bus.emit('mongosh:mongocryptd-log', { pid: proc.pid, logEntry });
        });
        return proc;
    }
    async _spawn() {
        var _a;
        if (this.spawnPaths.length === 0) {
            throw new errors_1.MongoshInternalError('No mongocryptd spawn path given');
        }
        await fs_1.promises.mkdir(this.path, { recursive: true, mode: 0o700 });
        process.on('exit', this.close);
        let proc = undefined;
        let uri = '';
        let lastError = undefined;
        for (const spawnPath of this.spawnPaths) {
            this.bus.emit('mongosh:mongocryptd-tryspawn', { spawnPath, path: this.path });
            try {
                proc = this._spawnMongocryptdProcess(spawnPath);
            }
            catch (error) {
                lastError = error;
                this.bus.emit('mongosh:mongocryptd-error', { cause: 'spawn', error });
                continue;
            }
            proc.on('error', (error) => {
                lastError = error;
                this.bus.emit('mongosh:mongocryptd-error', { cause: 'spawn', error });
            });
            let stderr = '';
            (_a = proc.stderr) === null || _a === void 0 ? void 0 : _a.setEncoding('utf8').on('data', chunk => { stderr += chunk; });
            const { pid } = proc;
            const logEntryStream = stream_1.Readable.from(this.createLogEntryIterator(proc.stdout, pid));
            const { socket, port } = await filterLogStreamForSocketAndPort(logEntryStream);
            if (!socket && port === -1) {
                proc.kill();
                this.bus.emit('mongosh:mongocryptd-error', { cause: 'nostdout', stderr });
                continue;
            }
            logEntryStream.resume();
            uri = !socket ? `mongodb://localhost:${port}` : `mongodb://${encodeURIComponent(socket)}`;
            break;
        }
        if (!proc || !uri) {
            throw lastError !== null && lastError !== void 0 ? lastError : new errors_1.MongoshInternalError('Could not successfully spawn mongocryptd');
        }
        const interval = setInterval(async () => {
            let sp;
            try {
                sp = await service_provider_server_1.CliServiceProvider.connect(uri, {
                    serverSelectionTimeoutMS: this.idleShutdownTimeoutSecs * 1000
                }, {}, this.bus);
                await sp.runCommandWithCheck('admin', { isMaster: 1 });
            }
            catch (error) {
                this.bus.emit('mongosh:mongocryptd-error', { cause: 'ping', error });
            }
            finally {
                if (sp !== undefined) {
                    await sp.close(true);
                }
            }
        }, this.idleShutdownTimeoutSecs * 1000 / 2);
        interval.unref();
        proc.unref();
        return { uri, proc, interval };
    }
    async _cleanupOldMongocryptdDirectories() {
        try {
            const toBeRemoved = [];
            for await (const dirent of await fs_1.promises.opendir(path_1.default.resolve(this.path, '..'))) {
                if (dirent.name.startsWith('mongocryptd-') && dirent.isDirectory()) {
                    let size = 0;
                    try {
                        size = (await fs_1.promises.stat(path_1.default.join(dirent.name, 'mongocryptd.pid'))).size;
                    }
                    catch (err) {
                        if (err.code !== 'ENOENT') {
                            throw err;
                        }
                    }
                    if (size === 0) {
                        toBeRemoved.push(path_1.default.join(this.path, '..', dirent.name));
                    }
                }
            }
            for (const dir of toBeRemoved) {
                if (path_1.default.resolve(dir) !== path_1.default.resolve(this.path)) {
                    await fs_1.promises.rmdir(dir, { recursive: true });
                }
            }
        }
        catch (error) {
            this.bus.emit('mongosh:mongocryptd-error', { cause: 'cleanup', error });
        }
    }
}
exports.MongocryptdManager = MongocryptdManager;
function getSocketFromLogEntry(logEntry) {
    let match;
    if (logEntry.id === 23015) {
        if (!net_1.isIP(logEntry.attr.address)) {
            return logEntry.attr.address;
        }
    }
    if (logEntry.id === undefined && (match = logEntry.message.match(/^Listening on (?<addr>.+)$/i))) {
        const { addr } = match.groups;
        if (!net_1.isIP(addr)) {
            return addr;
        }
    }
    return '';
}
function getPortFromLogEntry(logEntry) {
    var _a, _b;
    let match;
    if (logEntry.id === 23016) {
        return logEntry.attr.port;
    }
    if (logEntry.id === undefined && (match = logEntry.message.match(/^waiting for connections on port (?<port>\d+)$/i))) {
        return +((_b = (_a = match.groups) === null || _a === void 0 ? void 0 : _a.port) !== null && _b !== void 0 ? _b : '0');
    }
    return -1;
}
async function filterLogStreamForSocketAndPort(input) {
    let port = -1;
    let socket = '';
    const inputDuplicate = input.pipe(new stream_1.PassThrough({ objectMode: true }));
    for await (const logEntry of inputDuplicate) {
        if (logEntry.component !== 'NETWORK' || logEntry.context !== 'listener') {
            continue;
        }
        socket || (socket = getSocketFromLogEntry(logEntry));
        port = getPortFromLogEntry(logEntry);
        if (port !== -1) {
            break;
        }
    }
    return { socket, port };
}
//# sourceMappingURL=mongocryptd-manager.js.map
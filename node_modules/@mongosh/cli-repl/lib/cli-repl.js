"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("@mongosh/errors");
const history_1 = require("@mongosh/history");
const i18n_1 = __importDefault(require("@mongosh/i18n"));
const service_provider_core_1 = require("@mongosh/service-provider-core");
const service_provider_server_1 = require("@mongosh/service-provider-server");
const snippet_manager_1 = require("@mongosh/snippet-manager");
const editor_1 = require("@mongosh/editor");
const history_2 = require("@mongosh/history");
const analytics_node_1 = __importDefault(require("analytics-node"));
const askpassword_1 = __importDefault(require("askpassword"));
const mongodb_connection_string_url_1 = __importDefault(require("mongodb-connection-string-url"));
const nanobus_1 = __importDefault(require("nanobus"));
const semver_1 = __importDefault(require("semver"));
const build_info_1 = require("./build-info");
const config_directory_1 = require("./config-directory");
const error_codes_1 = require("./error-codes");
const mongodb_log_writer_1 = require("mongodb-log-writer");
const mongocryptd_manager_1 = require("./mongocryptd-manager");
const mongosh_repl_1 = __importDefault(require("./mongosh-repl"));
const logging_1 = require("@mongosh/logging");
const types_1 = require("@mongosh/types");
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const CONNECTING = 'cli-repl.cli-repl.connecting';
class CliRepl {
    constructor(options) {
        var _a, _b;
        this.warnedAboutInaccessibleFiles = false;
        this.closing = false;
        this.bus = new nanobus_1.default('mongosh');
        this.cliOptions = options.shellCliOptions;
        this.input = options.input;
        this.output = options.output;
        this.analyticsOptions = options.analyticsOptions;
        this.onExit = options.onExit;
        this.config = {
            userId: new service_provider_core_1.bson.ObjectId().toString(),
            enableTelemetry: true
        };
        this.shellHomeDirectory = new config_directory_1.ShellHomeDirectory(options.shellHomePaths);
        this.configDirectory = new config_directory_1.ConfigManager(this.shellHomeDirectory)
            .on('error', (err) => this.bus.emit('mongosh:error', err, 'config'))
            .on('new-config', (config) => this.bus.emit('mongosh:new-user', config.userId, config.enableTelemetry))
            .on('update-config', (config) => this.bus.emit('mongosh:update-user', config.userId, config.enableTelemetry));
        this.mongocryptdManager = new mongocryptd_manager_1.MongocryptdManager((_a = options.mongocryptdSpawnPaths) !== null && _a !== void 0 ? _a : [], this.shellHomeDirectory, this.bus);
        this.logManager = new mongodb_log_writer_1.MongoLogManager({
            directory: this.shellHomeDirectory.localPath('.'),
            retentionDays: 30,
            onerror: (err) => this.bus.emit('mongosh:error', err, 'log'),
            onwarn: (err, path) => this.warnAboutInaccessibleFile(err, path)
        });
        this.output.on('error', (err) => {
            this.bus.emit('mongosh:error', err, 'io');
        });
        this.mongoshRepl = new mongosh_repl_1.default({
            ...options,
            nodeReplOptions: (_b = options.nodeReplOptions) !== null && _b !== void 0 ? _b : {
                terminal: process.env.MONGOSH_FORCE_TERMINAL ? true : undefined,
            },
            bus: this.bus,
            ioProvider: this
        });
    }
    async start(driverUri, driverOptions) {
        var _a, _b;
        const { version } = require('../package.json');
        await this.verifyNodeVersion();
        if (!this.cliOptions.nodb) {
            const cs = new mongodb_connection_string_url_1.default(driverUri);
            if (!cs.searchParams.get('appName')) {
                cs.searchParams.set('appName', `mongosh ${version}`);
            }
            if (this.isPasswordMissingOptions(driverOptions)) {
                driverOptions.auth.password = await this.requirePassword();
            }
            else if (this.isPasswordMissingURI(cs)) {
                cs.password = await this.requirePassword();
            }
            this.ensurePasswordFieldIsPresentInAuth(driverOptions);
            driverUri = cs.href;
        }
        try {
            await this.shellHomeDirectory.ensureExists();
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err);
        }
        await this.logManager.cleanupOldLogfiles();
        const logger = await this.logManager.createLogWriter();
        if (!this.cliOptions.quiet) {
            this.output.write(`Current Mongosh Log ID:\t${logger.logId}\n`);
        }
        this.logWriter = logger;
        logger.info('MONGOSH', mongodb_log_writer_1.mongoLogId(1000000000), 'log', 'Starting log', {
            execPath: process.execPath,
            envInfo: history_2.redactSensitiveData(this.getLoggedEnvironmentVariables()),
            ...build_info_1.buildInfo()
        });
        logging_1.setupLoggerAndTelemetry(this.bus, logger, () => {
            var _a, _b, _c;
            if (process.env.IS_MONGOSH_EVERGREEN_CI && !((_a = this.analyticsOptions) === null || _a === void 0 ? void 0 : _a.alwaysEnable)) {
                throw new Error('no analytics setup for the mongosh CI environment');
            }
            this.analytics = new analytics_node_1.default((_c = (_b = this.analyticsOptions) === null || _b === void 0 ? void 0 : _b.apiKey) !== null && _c !== void 0 ? _c : require('./build-info.json').segmentApiKey, this.analyticsOptions);
            return this.analytics;
        }, {
            platform: process.platform,
            arch: process.arch
        }, require('../package.json').version);
        try {
            this.config = await this.configDirectory.generateOrReadConfig(this.config);
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err);
        }
        if (driverOptions.autoEncryption) {
            const extraOptions = {
                ...((_a = driverOptions.autoEncryption.extraOptions) !== null && _a !== void 0 ? _a : {}),
                ...(await this.startMongocryptd())
            };
            driverOptions.autoEncryption = { ...driverOptions.autoEncryption, extraOptions };
        }
        const initialServiceProvider = await this.connect(driverUri, driverOptions);
        const initialized = await this.mongoshRepl.initialize(initialServiceProvider);
        const commandLineLoadFiles = (_b = this.cliOptions.fileNames) !== null && _b !== void 0 ? _b : [];
        const willExecuteCommandLineScripts = commandLineLoadFiles.length > 0 || this.cliOptions.eval !== undefined;
        const willEnterInteractiveMode = !willExecuteCommandLineScripts || !!this.cliOptions.shell;
        let snippetManager;
        if (this.config.snippetIndexSourceURLs !== '') {
            snippetManager = snippet_manager_1.SnippetManager.create({
                installdir: this.shellHomeDirectory.roamingPath('snippets'),
                instanceState: this.mongoshRepl.runtimeState().instanceState,
                skipInitialIndexLoad: !willEnterInteractiveMode
            });
        }
        editor_1.Editor.create({
            input: this.input,
            vscodeDir: this.shellHomeDirectory.rcPath('.vscode'),
            tmpDir: this.shellHomeDirectory.localPath('editor'),
            instanceState: this.mongoshRepl.runtimeState().instanceState,
            loadExternalCode: this.mongoshRepl.loadExternalCode.bind(this.mongoshRepl)
        });
        if (willExecuteCommandLineScripts) {
            this.mongoshRepl.setIsInteractive(willEnterInteractiveMode);
            this.bus.emit('mongosh:start-loading-cli-scripts', { usesShellOption: !!this.cliOptions.shell });
            await this.loadCommandLineFilesAndEval(commandLineLoadFiles);
            if (!this.cliOptions.shell) {
                await this.exit(0);
                return;
            }
        }
        else {
            this.mongoshRepl.setIsInteractive(true);
        }
        if (!this.cliOptions.norc) {
            await (snippetManager === null || snippetManager === void 0 ? void 0 : snippetManager.loadAllSnippets());
        }
        await this.loadRcFiles();
        this.bus.emit('mongosh:start-mongosh-repl', { version });
        await this.mongoshRepl.startRepl(initialized);
    }
    async loadCommandLineFilesAndEval(files) {
        if (this.cliOptions.eval) {
            this.bus.emit('mongosh:eval-cli-script');
            const evalResult = await this.mongoshRepl.loadExternalCode(this.cliOptions.eval, '@(shell eval)');
            this.output.write(this.mongoshRepl.writer(evalResult) + '\n');
        }
        else if (this.cliOptions.eval === '') {
            const msg = 'Warning: --eval requires an argument, but no argument was given\n';
            this.output.write(this.clr(msg, ['bold', 'yellow']));
        }
        for (const file of files) {
            if (!this.cliOptions.quiet) {
                this.output.write(`Loading file: ${this.clr(file, ['bold', 'blue'])}\n`);
            }
            await this.mongoshRepl.loadExternalFile(file);
        }
    }
    async loadRcFiles() {
        if (this.cliOptions.norc) {
            return;
        }
        const legacyPath = this.shellHomeDirectory.rcPath('.mongorc.js');
        const mongoshrcPath = this.shellHomeDirectory.rcPath('.mongoshrc.js');
        const mongoshrcMisspelledPath = this.shellHomeDirectory.rcPath('.mongoshrc');
        let hasMongoshRc = false;
        try {
            await fs_1.promises.stat(mongoshrcPath);
            hasMongoshRc = true;
        }
        catch (_a) { }
        if (hasMongoshRc) {
            try {
                this.bus.emit('mongosh:mongoshrc-load');
                await this.mongoshRepl.loadExternalFile(mongoshrcPath);
            }
            catch (err) {
                this.output.write(this.clr('Error while running ~/.mongoshrc.js:\n', ['bold', 'yellow']));
                this.output.write(this.mongoshRepl.writer(err) + '\n');
            }
            return;
        }
        if (this.cliOptions.quiet) {
            return;
        }
        let hasLegacyRc = false;
        try {
            await fs_1.promises.stat(legacyPath);
            hasLegacyRc = true;
        }
        catch (_b) { }
        if (hasLegacyRc) {
            this.bus.emit('mongosh:mongoshrc-mongorc-warn');
            const msg = 'Warning: Found ~/.mongorc.js, but not ~/.mongoshrc.js. ~/.mongorc.js will not be loaded.\n' +
                '  You may want to copy or rename ~/.mongorc.js to ~/.mongoshrc.js.\n';
            this.output.write(this.clr(msg, ['bold', 'yellow']));
            return;
        }
        let hasMisspelledFilename = false;
        try {
            await fs_1.promises.stat(mongoshrcMisspelledPath);
            hasMisspelledFilename = true;
        }
        catch (_c) { }
        if (hasMisspelledFilename) {
            const msg = 'Warning: Found ~/.mongoshrc, but not ~/.mongoshrc.js. Did you forget to add .js?\n';
            this.output.write(this.clr(msg, ['bold', 'yellow']));
        }
    }
    warnAboutInaccessibleFile(err, path) {
        this.bus.emit('mongosh:error', err, 'config');
        if (this.warnedAboutInaccessibleFiles) {
            return;
        }
        this.warnedAboutInaccessibleFiles = true;
        const msg = `Warning: Could not access file${path ? 'at ' + path : ''}: ${err.message}\n`;
        this.output.write(this.clr(msg, ['bold', 'yellow']));
    }
    async connect(driverUri, driverOptions) {
        if (!this.cliOptions.nodb && !this.cliOptions.quiet) {
            this.output.write(i18n_1.default.__(CONNECTING) + '\t\t' + this.clr(history_1.redactURICredentials(driverUri), ['bold', 'green']) + '\n');
        }
        return await service_provider_server_1.CliServiceProvider.connect(driverUri, driverOptions, this.cliOptions, this.bus);
    }
    getHistoryFilePath() {
        return this.shellHomeDirectory.roamingPath('mongosh_repl_history');
    }
    async getConfig(key) {
        var _a;
        return (_a = this.config[key]) !== null && _a !== void 0 ? _a : (new types_1.CliUserConfig())[key];
    }
    async setConfig(key, value) {
        this.config[key] = value;
        if (key === 'enableTelemetry') {
            this.bus.emit('mongosh:update-user', this.config.userId, this.config.enableTelemetry);
        }
        try {
            await this.configDirectory.writeConfigFile(this.config);
        }
        catch (err) {
            this.warnAboutInaccessibleFile(err, this.configDirectory.path());
        }
        return 'success';
    }
    listConfigOptions() {
        const keys = Object.keys(new types_1.CliUserConfig());
        return keys.filter(key => key !== 'userId' && key !== 'disableGreetingMessage');
    }
    async verifyNodeVersion() {
        if (process.env.MONGOSH_SKIP_NODE_VERSION_CHECK) {
            return;
        }
        const { engines } = require('../package.json');
        const baseNodeVersion = process.version.replace(/-.*$/, '');
        if (!semver_1.default.satisfies(baseNodeVersion, engines.node)) {
            const warning = new errors_1.MongoshWarning(`Mismatched node version. Required version: ${engines.node}. Currently using: ${process.version}. Exiting...\n\n`, error_codes_1.CliReplErrors.NodeVersionMismatch);
            await this._fatalError(warning);
        }
    }
    isPasswordMissingOptions(driverOptions) {
        return !!(driverOptions.auth &&
            driverOptions.auth.username &&
            !driverOptions.auth.password &&
            driverOptions.authMechanism !== 'GSSAPI');
    }
    isPasswordMissingURI(cs) {
        return !!(cs.username &&
            !cs.password &&
            cs.searchParams.get('authMechanism') !== 'GSSAPI');
    }
    ensurePasswordFieldIsPresentInAuth(driverOptions) {
        if (driverOptions.auth && driverOptions.auth.username && !('password' in driverOptions.auth)) {
            driverOptions.auth.password = undefined;
        }
    }
    async requirePassword() {
        const passwordPromise = askpassword_1.default({
            input: this.input,
            output: this.output,
            replacementCharacter: '*'
        });
        this.output.write('Enter password: ');
        try {
            try {
                return (await passwordPromise).toString();
            }
            finally {
                this.output.write('\n');
            }
        }
        catch (error) {
            await this._fatalError(error);
        }
        return '';
    }
    async _fatalError(error) {
        this.bus.emit('mongosh:error', error, 'fatal');
        this.output.write(this.mongoshRepl.formatError(error) + '\n');
        return this.exit(1);
    }
    async close() {
        var _a, _b;
        if (this.closing) {
            return;
        }
        this.closing = true;
        const analytics = this.analytics;
        let flushError = null;
        let flushDuration = null;
        if (analytics) {
            const flushStart = Date.now();
            try {
                await util_1.promisify(analytics.flush.bind(analytics))();
            }
            catch (err) {
                flushError = err.message;
            }
            finally {
                flushDuration = Date.now() - flushStart;
            }
        }
        this.mongocryptdManager.close();
        (_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.info('MONGOSH', mongodb_log_writer_1.mongoLogId(1000000045), 'analytics', 'Flushed outstanding data', {
            flushError,
            flushDuration
        });
        await ((_b = this.logWriter) === null || _b === void 0 ? void 0 : _b.flush());
        this.bus.emit('mongosh:closed');
    }
    async exit(code) {
        await this.close();
        await this.onExit(code);
        const error = new errors_1.MongoshInternalError('onExit() unexpectedly returned');
        this.bus.emit('mongosh:error', error, 'fatal');
        throw error;
    }
    async readFileUTF8(filename) {
        const resolved = path_1.default.resolve(filename);
        return {
            contents: await fs_1.promises.readFile(resolved, 'utf8'),
            absolutePath: resolved
        };
    }
    clr(text, style) {
        return this.mongoshRepl.clr(text, style);
    }
    async startMongocryptd() {
        try {
            return await this.mongocryptdManager.start();
        }
        catch (e) {
            if (e.code === 'ENOENT') {
                throw new errors_1.MongoshRuntimeError('Could not find a working mongocryptd - ensure your local installation works correctly. See the mongosh log file for additional information. Please also refer to the documentation: https://docs.mongodb.com/manual/reference/security-client-side-encryption-appendix/');
            }
            throw e;
        }
    }
    bugReportErrorMessageInfo() {
        var _a;
        return `Please include the log file for this session (${(_a = this.logWriter) === null || _a === void 0 ? void 0 : _a.logFilePath}).`;
    }
    getLoggedEnvironmentVariables() {
        const { EDITOR, NODE_OPTIONS, TERM } = process.env;
        return { EDITOR, NODE_OPTIONS, TERM };
    }
}
exports.default = CliRepl;
//# sourceMappingURL=cli-repl.js.map
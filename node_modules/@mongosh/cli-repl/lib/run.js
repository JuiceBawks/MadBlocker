"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("./index");
const service_provider_server_1 = require("@mongosh/service-provider-server");
const history_1 = require("@mongosh/history");
const module_1 = require("module");
const readline_1 = __importDefault(require("readline"));
const askcharacter_1 = __importDefault(require("askcharacter"));
const stream_1 = __importDefault(require("stream"));
(async () => {
    if (process.env.MONGOSH_RUN_NODE_SCRIPT) {
        process.argv.splice(1, 1);
        module_1.runMain(process.argv[1]);
        return;
    }
    let repl;
    let isSingleConsoleProcess = false;
    try {
        const options = index_1.parseCliArgs(process.argv);
        for (const warning of options._argParseWarnings) {
            console.warn(warning);
        }
        const { version } = require('../package.json');
        if (options.help) {
            console.log(index_1.USAGE);
        }
        else if (options.version) {
            console.log(version);
        }
        else if (options.buildInfo) {
            console.log(JSON.stringify(index_1.buildInfo(), null, '  '));
        }
        else if (options.smokeTests) {
            const smokeTestServer = process.env.MONGOSH_SMOKE_TEST_SERVER;
            if (process.execPath === process.argv[1]) {
                await index_1.runSmokeTests(smokeTestServer, process.execPath);
            }
            else {
                await index_1.runSmokeTests(smokeTestServer, process.execPath, process.argv[1]);
            }
        }
        else {
            let mongocryptdSpawnPaths = [['mongocryptd']];
            if (process.execPath === process.argv[1]) {
                process.removeAllListeners('warning');
                mongocryptdSpawnPaths = await index_1.getMongocryptdPaths();
            }
            if (process.env.CLEAR_SIGINT_LISTENERS) {
                process.removeAllListeners('SIGINT');
            }
            isSingleConsoleProcess = !!process.env.MONGOSH_FORCE_CONNECTION_STRING_PROMPT;
            if ((!options.connectionSpecifier &&
                process.platform === 'win32' &&
                process.stdin.isTTY &&
                process.stdout.isTTY) ||
                isSingleConsoleProcess) {
                try {
                    isSingleConsoleProcess || (isSingleConsoleProcess = require('get-console-process-list')().length === 1);
                }
                catch (_a) { }
                if (isSingleConsoleProcess) {
                    const result = await ask('Please enter a MongoDB connection string (Default: mongodb://localhost/): ');
                    if (result.trim() !== '') {
                        options.connectionSpecifier = result.trim();
                    }
                }
            }
            const driverOptions = index_1.mapCliToDriver(options);
            const driverUri = service_provider_server_1.generateUri(options);
            const title = `mongosh ${history_1.redactURICredentials(driverUri)}`;
            process.title = title;
            setTerminalWindowTitle(title);
            const shellHomePaths = index_1.getStoragePaths();
            repl = new index_1.CliRepl({
                shellCliOptions: {
                    ...options,
                },
                mongocryptdSpawnPaths,
                input: process.stdin,
                output: process.stdout,
                onExit: process.exit,
                shellHomePaths: shellHomePaths
            });
            await repl.start(driverUri, driverOptions);
        }
    }
    catch (e) {
        console.error(`${e.name}: ${e.message}`);
        if (repl !== undefined) {
            repl.bus.emit('mongosh:error', e, 'startup');
        }
        if (isSingleConsoleProcess) {
            process.stdout.write('Press any key to exit: ');
            await askcharacter_1.default({ input: process.stdin, output: process.stdout });
            process.stdout.write('\n');
        }
        process.exit(1);
    }
})();
function setTerminalWindowTitle(title) {
    var _a;
    if (!process.stdout.isTTY) {
        return;
    }
    const term = (_a = process.env.TERM) !== null && _a !== void 0 ? _a : '';
    if (/^(linux|xterm|rxvt)/.test(term)) {
        process.stdout.write(`\u001b]0;${title}\u0007`);
    }
    else if (/^screen/.test(term)) {
        process.stdout.write(`\u001bk${title}\u001b\\`);
    }
}
async function ask(prompt) {
    const stdinCopy = process.stdin.pipe(new stream_1.default.PassThrough());
    try {
        const readlineInterface = readline_1.default.createInterface({
            input: stdinCopy,
            output: process.stdout,
            prompt,
        });
        readlineInterface.prompt();
        for await (const line of readlineInterface) {
            return line;
        }
        return '';
    }
    finally {
        process.stdin.unpipe(stdinCopy);
    }
}
//# sourceMappingURL=run.js.map
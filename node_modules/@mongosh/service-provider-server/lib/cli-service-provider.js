"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongodb_1 = require("mongodb");
const service_provider_core_1 = require("@mongosh/service-provider-core");
const devtools_connect_1 = require("@mongodb-js/devtools-connect");
const errors_1 = require("@mongosh/errors");
const mongodb_patches_1 = require("./mongodb-patches");
const mongodb_connection_string_url_1 = __importDefault(require("mongodb-connection-string-url"));
const events_1 = require("events");
const bsonlib = {
    Binary: mongodb_1.Binary,
    Code: mongodb_1.Code,
    DBRef: mongodb_1.DBRef,
    Double: mongodb_1.Double,
    Int32: mongodb_1.Int32,
    Long: mongodb_1.Long,
    MinKey: mongodb_1.MinKey,
    MaxKey: mongodb_1.MaxKey,
    ObjectId: mongodb_1.ObjectId,
    Timestamp: mongodb_1.Timestamp,
    Decimal128: mongodb_1.Decimal128,
    BSONSymbol: mongodb_1.BSONSymbol,
    Map: service_provider_core_1.bson.Map,
    calculateObjectSize: service_provider_core_1.bson.calculateObjectSize,
    EJSON: service_provider_core_1.bson.EJSON,
    BSONRegExp: mongodb_1.BSONRegExp
};
const DEFAULT_DRIVER_OPTIONS = Object.freeze({});
function processDriverOptions(opts) {
    return { ...DEFAULT_DRIVER_OPTIONS, ...opts };
}
const DEFAULT_BASE_OPTIONS = Object.freeze({
    serializeFunctions: true,
    promoteLongs: false
});
class CliServiceProvider extends service_provider_core_1.ServiceProviderCore {
    constructor(mongoClient, bus, clientOptions = {}, uri) {
        super(bsonlib);
        mongodb_patches_1.ensureMongoNodeNativePatchesAreApplied();
        this.bus = bus;
        this.mongoClient = mongoClient;
        this.uri = uri;
        this.platform = service_provider_core_1.ReplPlatform.CLI;
        try {
            this.initialDb = mongoClient.s.options.dbName || service_provider_core_1.DEFAULT_DB;
        }
        catch (err) {
            this.initialDb = service_provider_core_1.DEFAULT_DB;
        }
        this.currentClientOptions = clientOptions;
        this.baseCmdOptions = { ...DEFAULT_BASE_OPTIONS };
        this.dbcache = new WeakMap();
        try {
            this.fle = require('mongodb-client-encryption');
        }
        catch (_a) { }
    }
    static async connect(uri, driverOptions = {}, cliOptions = {}, bus = new events_1.EventEmitter()) {
        var _a, _b;
        const connectionString = new mongodb_connection_string_url_1.default(uri || 'mongodb://nodb/');
        const clientOptions = processDriverOptions(driverOptions);
        if (process.env.MONGOSH_TEST_FORCE_API_STRICT) {
            clientOptions.serverApi = {
                version: typeof clientOptions.serverApi === 'string' ? clientOptions.serverApi :
                    ((_b = (_a = clientOptions.serverApi) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : '1'),
                strict: true,
                deprecationErrors: true
            };
        }
        const mongoClient = !cliOptions.nodb ?
            await devtools_connect_1.connectMongoClient(connectionString.toString(), clientOptions, bus, mongodb_1.MongoClient) :
            new mongodb_1.MongoClient(connectionString.toString(), clientOptions);
        return new this(mongoClient, bus, clientOptions, connectionString);
    }
    async getNewConnection(uri, options = {}) {
        const connectionString = new mongodb_connection_string_url_1.default(uri);
        const clientOptions = processDriverOptions(options);
        const mongoClient = await devtools_connect_1.connectMongoClient(connectionString.toString(), clientOptions, this.bus, mongodb_1.MongoClient);
        return new CliServiceProvider(mongoClient, this.bus, clientOptions, connectionString);
    }
    async getConnectionInfo() {
        var _a, _b, _c;
        let buildInfo;
        try {
            buildInfo = await this.runCommandWithCheck('admin', {
                buildInfo: 1
            }, this.baseCmdOptions);
        }
        catch (e) {
            if (e.message.includes('not supported for auto encryption')) {
                const options = { ...this.currentClientOptions };
                delete options.autoEncryption;
                const unencrypted = await this.getNewConnection(this.uri.toString(), options);
                try {
                    return await unencrypted.getConnectionInfo();
                }
                finally {
                    await unencrypted.close(true);
                }
            }
        }
        const topology = this.getTopology();
        const { version } = require('../package.json');
        const [cmdLineOpts = null, atlasVersion = null, fcv = null] = await Promise.all([
            this.runCommandWithCheck('admin', { getCmdLineOpts: 1 }, this.baseCmdOptions).catch(() => { }),
            this.runCommandWithCheck('admin', { atlasVersion: 1 }, this.baseCmdOptions).catch(() => { }),
            this.runCommandWithCheck('admin', { getParameter: 1, featureCompatibilityVersion: 1 }, this.baseCmdOptions).catch(() => { })
        ]);
        const extraConnectionInfo = service_provider_core_1.getConnectInfo((_b = (_a = this.uri) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', version, buildInfo, cmdLineOpts, atlasVersion, topology);
        return {
            buildInfo: buildInfo,
            topology: topology,
            extraInfo: {
                ...extraConnectionInfo,
                fcv: (_c = fcv === null || fcv === void 0 ? void 0 : fcv.featureCompatibilityVersion) === null || _c === void 0 ? void 0 : _c.version
            }
        };
    }
    async renameCollection(database, oldName, newName, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return await this.db(database, dbOptions).renameCollection(oldName, newName, options);
    }
    db(name, dbOptions = {}) {
        const key = `${name}-${JSON.stringify(dbOptions)}`;
        const dbcache = this.getDBCache();
        const cached = dbcache.get(key);
        if (cached) {
            return cached;
        }
        const db = this.mongoClient.db(name, dbOptions);
        dbcache.set(key, db);
        return db;
    }
    _dbTestWrapper(name, dbOptions) {
        return this.db(name, dbOptions);
    }
    getDBCache() {
        const existing = this.dbcache.get(this.mongoClient);
        if (existing) {
            return existing;
        }
        this.dbcache.set(this.mongoClient, new Map());
        return this.getDBCache();
    }
    aggregate(database, collection, pipeline = [], options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .aggregate(pipeline, options);
    }
    aggregateDb(database, pipeline = [], options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        const db = this.db(database, dbOptions);
        return db.aggregate(pipeline, options);
    }
    bulkWrite(database, collection, requests, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .bulkWrite(requests, options);
    }
    close(force) {
        this.dbcache.set(this.mongoClient, new Map());
        return this.mongoClient.close(force);
    }
    async suspend() {
        await this.close(true);
        return async () => {
            await this.resetConnectionOptions({});
        };
    }
    count(database, collection, query = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .count(query, options);
    }
    countDocuments(database, collection, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .countDocuments(filter, options);
    }
    deleteMany(database, collection, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .deleteMany(filter, options);
    }
    deleteOne(database, collection, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .deleteOne(filter, options);
    }
    distinct(database, collection, fieldName, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .distinct(fieldName, filter, options);
    }
    estimatedDocumentCount(database, collection, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .estimatedDocumentCount(options);
    }
    find(database, collection, filter = {}, options = {}, dbOptions) {
        const findOptions = { ...this.baseCmdOptions, ...options };
        if ('allowPartialResults' in findOptions) {
            findOptions.partial = findOptions.allowPartialResults;
        }
        if ('noCursorTimeout' in findOptions) {
            findOptions.timeout = findOptions.noCursorTimeout;
        }
        return this.db(database, dbOptions)
            .collection(collection)
            .find(filter, findOptions);
    }
    findOneAndDelete(database, collection, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection).
            findOneAndDelete(filter, options);
    }
    findOneAndReplace(database, collection, filter = {}, replacement = {}, options = {}, dbOptions) {
        const findOneAndReplaceOptions = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions).collection(collection).findOneAndReplace(filter, replacement, findOneAndReplaceOptions);
    }
    findOneAndUpdate(database, collection, filter = {}, update = {}, options = {}, dbOptions) {
        const findOneAndUpdateOptions = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .findOneAndUpdate(filter, update, findOneAndUpdateOptions);
    }
    insertMany(database, collection, docs = [], options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .insertMany(docs, options);
    }
    async insertOne(database, collection, doc = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .insertOne(doc, options);
    }
    isCapped(database, collection, dbOptions) {
        return this.db(database, dbOptions).collection(collection).isCapped();
    }
    remove(database, collection, query = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions).collection(collection).remove(query, options);
    }
    replaceOne(database, collection, filter = {}, replacement = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .replaceOne(filter, replacement, options);
    }
    runCommand(database, spec = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        const db = this.db(database, dbOptions);
        return db.command(spec, options);
    }
    async runCommandWithCheck(database, spec = {}, options = {}, dbOptions) {
        const result = await this.runCommand(database, spec, options, dbOptions);
        if (result.ok === 0) {
            throw new errors_1.MongoshCommandFailed(JSON.stringify(spec));
        }
        return result;
    }
    listDatabases(database, options = {}) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database).admin().listDatabases(options);
    }
    async updateMany(database, collection, filter = {}, update = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return await this.db(database, dbOptions)
            .collection(collection)
            .updateMany(filter, update, options);
    }
    updateOne(database, collection, filter = {}, update = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .updateOne(filter, update, options);
    }
    getTopology() {
        return this.mongoClient.topology;
    }
    async dropDatabase(db, options = {}, dbOptions = {}) {
        const opts = { ...this.baseCmdOptions, ...options };
        const nativeResult = await this.db(db, dbOptions).dropDatabase(opts);
        const ok = nativeResult ? 1 : 0;
        return {
            ok,
            ...(ok ? { dropped: db } : {})
        };
    }
    async createIndexes(database, collection, indexSpecs, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return this.db(database, dbOptions)
            .collection(collection)
            .createIndexes(indexSpecs, options);
    }
    async getIndexes(database, collection, options = {}, dbOptions) {
        return this.db(database, dbOptions)
            .collection(collection)
            .listIndexes({ ...this.baseCmdOptions, ...options })
            .toArray();
    }
    async listCollections(database, filter = {}, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return await this.db(database, dbOptions).listCollections(filter, options).toArray();
    }
    async stats(database, collection, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        return await this.db(database, dbOptions)
            .collection(collection)
            .stats(options);
    }
    async dropCollection(database, collection, options = {}, dbOptions) {
        return this.db(database, dbOptions)
            .collection(collection)
            .drop({ ...this.baseCmdOptions, ...options });
    }
    async authenticate(authDoc) {
        const auth = { username: authDoc.user, password: authDoc.pwd };
        await this.resetConnectionOptions({
            auth,
            ...(authDoc.mechanism ? { authMechanism: authDoc.mechanism } : {}),
            ...(authDoc.authDb ? { authSource: authDoc.authDb } : {})
        });
        return { ok: 1 };
    }
    async createCollection(dbName, collName, options = {}, dbOptions) {
        options = { ...this.baseCmdOptions, ...options };
        await this.db(dbName, dbOptions).createCollection(collName, options);
        return { ok: 1 };
    }
    async initializeBulkOp(dbName, collName, ordered, options = {}, dbOptions) {
        if (ordered) {
            return this.db(dbName, dbOptions).collection(collName).initializeOrderedBulkOp(options);
        }
        return this.db(dbName, dbOptions).collection(collName).initializeUnorderedBulkOp(options);
    }
    getReadPreference() {
        return this.mongoClient.readPreference;
    }
    getReadConcern() {
        return this.mongoClient.readConcern;
    }
    getWriteConcern() {
        return this.mongoClient.writeConcern;
    }
    readPreferenceFromOptions(options) {
        return mongodb_1.ReadPreference.fromOptions(options);
    }
    async resetConnectionOptions(options) {
        this.bus.emit('mongosh-sp:reset-connection-options');
        this.currentClientOptions = {
            ...this.currentClientOptions,
            ...options
        };
        const clientOptions = processDriverOptions(this.currentClientOptions);
        const mc = await devtools_connect_1.connectMongoClient(this.uri.toString(), clientOptions, this.bus, mongodb_1.MongoClient);
        try {
            await this.mongoClient.close();
        }
        catch (_a) { }
        this.mongoClient = mc;
    }
    startSession(options) {
        return this.mongoClient.startSession(options);
    }
    watch(pipeline, options, dbOptions = {}, db, coll) {
        if (db === undefined && coll === undefined) {
            return this.mongoClient.watch(pipeline, options);
        }
        else if (db !== undefined && coll === undefined) {
            return this.db(db, dbOptions).watch(pipeline, options);
        }
        else if (db !== undefined && coll !== undefined) {
            return this.db(db, dbOptions).collection(coll).watch(pipeline, options);
        }
        throw new errors_1.MongoshInternalError('Cannot call watch with defined collection but undefined db');
    }
    get driverMetadata() {
        var _a;
        return (_a = this.getTopology()) === null || _a === void 0 ? void 0 : _a.clientMetadata;
    }
    getRawClient() {
        return this.mongoClient;
    }
    getURI() {
        var _a;
        return (_a = this.uri) === null || _a === void 0 ? void 0 : _a.href;
    }
    getFleOptions() {
        return this.currentClientOptions.autoEncryption;
    }
}
exports.default = CliServiceProvider;
//# sourceMappingURL=cli-service-provider.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureMongoNodeNativePatchesAreApplied = void 0;
const errors_1 = require("@mongosh/errors");
let alreadyPatched = false;
function ensureMongoNodeNativePatchesAreApplied() {
    if (alreadyPatched) {
        return;
    }
    patchConnectionPoolTracking();
    alreadyPatched = true;
}
exports.ensureMongoNodeNativePatchesAreApplied = ensureMongoNodeNativePatchesAreApplied;
const poolToConnections = new Map();
function patchConnectionPoolTracking() {
    const connectionPoolPrototype = require('mongodb/lib/cmap/connection_pool').ConnectionPool.prototype;
    if (!connectionPoolPrototype) {
        throw new errors_1.MongoshInternalError('Failed to setup connection handling');
    }
    const originalCheckOut = connectionPoolPrototype.checkOut;
    const newCheckOut = function (cb) {
        const pool = this;
        originalCheckOut.call(this, function (error, connection) {
            if (connection) {
                let connections = poolToConnections.get(pool);
                if (!connections) {
                    connections = new Set();
                    poolToConnections.set(pool, connections);
                }
                connections.add(connection);
            }
            cb.call(this, error, connection);
        });
    };
    connectionPoolPrototype.checkOut = newCheckOut;
    const originalCheckIn = connectionPoolPrototype.checkIn;
    const newCheckIn = function (connection) {
        if (connection) {
            const connections = poolToConnections.get(this);
            if (connections) {
                connections.delete(connection);
            }
        }
        originalCheckIn.call(this, connection);
    };
    connectionPoolPrototype.checkIn = newCheckIn;
    const originalClose = connectionPoolPrototype.close;
    const newClose = function (options, cb) {
        const pool = this;
        const connections = poolToConnections.get(pool);
        if (!pool.closed && connections && typeof options === 'object' && options.force) {
            const originalCallback = cb;
            cb = function (error, result) {
                poolToConnections.delete(pool);
                for (const c of connections) {
                    c.destroy({ force: true });
                    c.handleIssue({ destroy: new Error('connection canceled by force close') });
                }
                if (originalCallback) {
                    originalCallback.call(this, error, result);
                }
            };
        }
        originalClose.call(this, options, cb);
    };
    connectionPoolPrototype.close = newClose;
}
//# sourceMappingURL=mongodb-patches.js.map